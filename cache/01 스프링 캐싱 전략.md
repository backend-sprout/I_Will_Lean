# 캐싱 추상화 이해 
 
스프링 프레임워크는 3.1 버전 이후부터,      
트랜잭션 처럼, **캐시를 투명하게 추가할 수 있도록 기능을 지원하기 시작했다.(PSA 의미)**       
**즉, 캐싱 추상화를 통해 코드에 미치는 영향을 최소화하면서 다양한 캐싱 솔루션을 일관되게 사용할 수 있게한다.**    
  
**버퍼와 캐싱의 차이**   
```
버퍼는 데이터를 한번에 처리하기 위한 저장소의 역할을 맡고있다.   
즉, 버퍼는 전체 데이터 블록을 작은 청크로 이동하는 것이 아니라 한번에 이동시킨다.    
   
캐싱은 정의상 숨겨져있으며, 어느쪽도 캐싱이 발생하는 것을 인식하지 못한다.       
또한, 성능을 향상시키는 작업이지만, 동일한 데이터를 빠른 속도로 여러번 읽을 수 있다.    
(버퍼는 동일한 데이터를 읽으려면 버퍼를 기다려야하던가 해야한다.).  
```
  
## 캐싱 동작   
스프링의 캐싱 추상화는, 프록시 기반으로 동작하기에 Java 메서드를 기준으로 캐싱한다.       
즉, 해당 메서드의 실행 횟수를 줄이는 것을 목표로 하고 있다.(추상화는 호출 여부를 판단하고 캐싱 동작 진행) 
단, 동일한 출력을 반환하는 것이 보장된 메서드에 대해서만 권유하고 실제로 이같은 경우에만 동작한다.      
     
* 이전에 호출 안함 : 메서드 실행     
* 이전에 호출함 : 추상화와 연관도니 캐싱 데이터 스토리지(저장소)에서 값을 반환    

## 캐싱과 업데이트 삭제 
캐싱 추상화는 캐싱 업데이트 및 제거와 같은 작업들도 도맡아 준다.    
이를 통해 개발자는 별도의 작업 없이도 리캐싱과 캐싱 삭제를 할 필요는 없다.   

## 캐싱 스토어 
         
스프링 프레임워크가 제공하는 캐싱 서비스는 구현이 아닌 추상화이다.             
그리고 캐싱 추상화는 다양한 캐시 데이터를 저장하는 스토리지를 사용할 수 있도록 설계되어있다.    
**즉, 추상화를 통해 캐싱을 위한 논리적인 코드를 작성할 필요는 없지만, 실제 데이터를 제공할 수 있어야한다.**    
  
이러한 추상화는 아래와 같은 인터페이스로 이루어진다.  

* org.springframework.cache.Cache 
* org.springframework.cache.CacheManager interfaces.

**스프링이 제공해주는 기본 캐싱**    
스프링 프레임워크는 아래와 같은 캐싱 스토어를 기본적으로 제공해준다.    

* java.util.concurrent.ConcurrentMap based caches
* Ehcache 2.x
* Gemfire cache
* Caffeine
* JSR-107 compliant caches (such as Ehcache 3.x).
* 레디스 등등 
  
```. 
캐싱 추상화는 캐시 구현에 의해 처리되기 때문에   
멀티 스레드 및 멀티 프로세스 환경에 대한 특별한 처리가 없습니다.   
```

## 캐싱과 멀티 프로세싱 
    
멀티 프로세싱 환경이라면, 환경에 맞는 캐싱을 사용해야한다.        
사용 사례에 따라, 여러 노드에 있는 동일한 데이터의 복사본으로도 충분할 수 있다.       
그러나 응용 프로그램이 진행되는 동안 데이터를 변경하는 경우 다른 전파 메커니즘을 활성화해야 할 수 있다.  
    
특정 항목을 캐싱하는 것은 전형 적인 캐싱 방법과 동일하다.(있으면 꺼내고 없으면 직접 찾고)   
잠금이 적용되지 않으며 여러 스레드가 동시에 동일한 항목을 로드하려고 할 수 있다. 
     
업데이트 및 제거에서도 마찬가지이다.     
여러 스레드가 동시에 데이터를 업데이트하거나 제거하려는 경우 오래된 데이터를 사용할 수 있다.   
특정 캐시 제공자들은 해당 영역에서 고급 기능을 제공하기도 한다.   
자세한 내용은 캐시 제공자의 설명서를 참조하자.









