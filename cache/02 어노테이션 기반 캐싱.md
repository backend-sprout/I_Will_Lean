# 어노테이션 기반 캐싱 

Spring의 캐싱 추상화는 Java 어노테이션을 지원한다.     
    
* @Cacheable: 캐싱을 적용할 메서드를 지정한다.  
* @CacheEvict: Triggers cache eviction.
* @CachePut: Updates the cache without interfering with the method execution.
* @Caching: Regroups multiple cache operations to be applied on a method.
* @CacheConfig: Shares some common cache-related settings at class-level.

## @Cacheable 어노테이션
  
캐시할 수 있는 메서드를 지정하는데 사용한다.      
즉, 이 어노테이션을 사용한 메서드는 결과를 캐시에 저장하므로     
**뒤이은 호출(같은 인자일 때)에는 실제로 메서드를 실행하지 않고 캐시에 저장된 값을 반환한다.**      

```java
@Cacheable("books")
public Book findBook(ISBN isbn) {...}
```
* 가장 간단한 형식으로는 **어노테이션이 붙은 메서드와 연관된 캐시의 이름만 있으면 어노테이션을 선언할 수 있다.**.   
* findBook 메서드는 books라는 캐시와 연결된다.    

이제 `findBook()`을 실행할 때마다 호출 이력을 확인하고 이에 따른 로직을 수행한다.   

```java
@Cacheable({ "books", "isbns" })
public Book findBook(ISBN isbn) {...}
```
  
어노테이션은 여러 이름을 지정해서 한 캐시를 여러 번 사용할 수 있다.      
이 경우 메서드를 실행하기 전에 각 캐시를 확인할 것이고     
최소 하나의 캐시에 저장되어 있다면 해당 값을 반환할 것이다.  

### 키 생성 전략 
  
캐시는 본직적으로 `key-value` 형태로 동작을 한다.     
**캐시된 메서드를 호출할 때마다, 해당 키로 변횐되어야한다는 뜻이기도 한다.**       
   
* 파라미터가 없으면 0을 반환한다.       
* 파라미터가 하나만 있으면 해당 인스턴스를 반환한다.    
* 파라미터가 둘 이상이라면, 파라미터의 해시를 계산한 키를 반환한다.  

이 같은 방식은 객체를 리플랙션하는 hashCode()처럼 일반적인 키를 가진 객체와 잘 동작한다.     
   
만약, 분산 혹은 유지(persistent)되는 환경이라면 객체가 hashCode를 보관하지 않도록 전략을 변경해야 한다.           
사실 JVM 구현체나 운영하는 환경에 따라 같은 VM 인스턴스에서 hashCode를 다른 객체에서 재사용할 수 있다.     

앞서 언급한 것처럼, 필요에 따라 다른 키 생성자를 제공하려면    
` org.springframework.cache.KeyGenerator` 인터페이스를 구현해야 한다.    
이를 구성하면, 키를 지정하지 않은 모든 선언에서는 위 구현체를 이용할 것이다.   

```   
기본키 전략은 스프링 4.0 릴리즈와 함께 변경되었다.      
이전 버전의 기본 키 생성 전략인 DefaultKeyGenerator 은     
여러 키 파라미터 방식때, `equals()` 말고 `hashcode()`만 고려했었고 이로 인해 예기치 않은 키 충돌이 발생했었다.  
이를 해결하기 위해 스프링 4.0 이후부터는 SimpleKeyGenerator를 도입했고 복합 키를 사용하도록 변경되었다.     
  
물론, 이전 방식을 사용하고자 한다면 deprecated된 DefaultKeyGenerator 를 사용하거나, 커스텀해서 적용해야 한다.         
```    





### 커스텀 키 생성 






