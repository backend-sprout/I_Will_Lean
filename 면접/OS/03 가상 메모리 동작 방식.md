# 가상 메모리      
      
하드디스크의 일부를 마치 메모리처럼 사용할 수 있게 해주는 기술로,         
**프로그램의 전체가 메인 메모리에 올라오지 않더라도 필요한 부분만 불러와 실행하는 기법**     

당장에 쓰이는 것들은 메인 메모리에 올리고      
당장에 쓰이지 않는 것들은 하드디스크에 저장한다.      
                  
가상메모리로 쓰이는 하드디스크의 영역을 스왑영역(Swap Space)라고 부르고,              
프로세스의 데이터들은 하드디스크에 저장되기 때문에 속도에 문제가 생길 수 있다.       
이를 해결하기 위해 각각의 프로세스마다 swap 파일을 만들고 메모리에 캐싱하는 방식으로 사용한다.(크기는 30%이하)         
         
하드디스크와 메인 메모리에 프로세스의 일부분만 저장하기 때문에        
이들을 나누는 기준이 필요한데 이때 페이징, 세그먼트가 있다.       
   
* 물리 메모리 크기에 제약받지 않게 된다.    
* 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 응답시간은 유지되고, CPU 이용률과 처리율은 높아진다.
* swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.
   
# Paging(페이징)
외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로,       
논리 메모리는 **Page** 로 불리는 고정 크기의 블록으로 분리한다.            
물리 메모리는 **Frame Page**라는 고정 크기로 분리한다.            
Frmae Page는 각각의 Page 와 동일한 크기로 분리되어 있고 이를 **Frame** 이라고 말한다.              
  
![프레젠테이션1](https://user-images.githubusercontent.com/50267433/138481193-dcd34acb-63de-4578-92e4-b7a27d6b1bfc.png)    
  
페이징 기법을 사용함으로써 논리 메모리의 페이지는 물리 메모리의 프레임에 저장될 때,         
**연속되어 저장될 필요가 없고** 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있다.  
이 과정에서 캐싱 알고리즘이 사용되어, Swapping을 진행한다.      
     
하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서),   
개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있다.   
       
**단점**    
* 내부 단편화 문제의 비중이 늘어나게 된다. 
    * 페이지 크기가 1,024B 이고 프로세스 A 가 2,172B 의 메모리를 요구한다면    
    * 2 개의 프레임(1,024 * 2 = 2,048) 하고도 124B 가 부족하기 때문에 총 3개의 프레임이 필요하다.   
    * 결론적으로 3번째 페이지 프레임에는 900B(1,024 - 124)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하는 것이다.    
   
## Segmentation(세그멘테이션)  
페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌,   
서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위)    
세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장      

단점 : 
서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 
자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)
  
  
# 내부 단편화 : 낭비 
    
![image](https://user-images.githubusercontent.com/50267433/138485002-c05489f0-8ad1-41be-a683-fe791ec8a741.png)
  
프로세스가 할당 받아 사용하는 영역에서 일부만 사용하고 나머지는 사용하지 않아 발생하는 낭비되는 문제    
    
# 외부 단편화 : 부족   
  
![image](https://user-images.githubusercontent.com/50267433/138484950-293d6a63-0c3a-4fb5-8fd6-305320c38fd8.png)
       
흩어진 메모리 공간의 총합은 여유가 있으나      
단편화로 인하여 일정 크기 이상의 새로운 프로세스가 하나의 메모리 영역에 할당하지 못하고 있음을 의미       
   
# Page fault trap(페이지 부재 트랩)
## 페이지 교체

`요구 페이징` 에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 `page fault(페이지 부재)`가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. 하지만, 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야 한다.(또는, 운영체제가 프로세스를 강제 종료하는 방법이 있다.)

### 기본적인 방법

물리 메모리가 모두 사용중인 상황에서의 메모리 교체 흐름이다.

1.  디스크에서 필요한 페이지의 위치를 찾는다
1.  빈 페이지 프레임을 찾는다.
    1.  `페이지 교체 알고리즘`을 통해 희생될(victim) 페이지를 고른다.
    1.  희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
1.  새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
1.  사용자 프로세스 재시작

### 페이지 교체 알고리즘

1. FIFO: 선입 선출 구조 
2. LRU : 가장 사용되지 않은 페이지 삭제 
3. LFU : 첨조 횟수가 가장 적은 페이지 삭제 


