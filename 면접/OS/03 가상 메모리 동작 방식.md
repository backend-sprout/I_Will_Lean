# 가상 메모리      
      
하드디스크의 일부를 마치 메모리처럼 사용할 수 있게 해주는 기술로,         
**프로그램의 전체가 메인 메모리에 올라오지 않더라도 필요한 부분만 불러와 실행하는 기법**     

당장에 쓰이는 것들은 메인 메모리에 올리고      
당장에 쓰이지 않는 것들은 하드디스크에 저장한다.      
                
가상메모리로 쓰이는 하드디스크의 영역을 스왑영역(Swap Space)라고 부르고,            
프로세스의 데이터들은 하드디스크에 저장되기 때문에 속도에 문제가 생길 수 있다.     
이를 해결하기 위해 각각의 프로세스마다 swap 파일을 만들고 이를 캐싱하는 형태로 사용한다.     
        
하드디스크와 메인 메모리에 프로세스의 일부분만 저장하기 때문에        
이들을 나누는 기준이 필요한데 이때 페이징, 세그먼트가 있다.       
   
* 물리 메모리 크기에 제약받지 않게 된다.
* 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 응답시간은 유지되고, CPU 이용률과 처리율은 높아진다.
* swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.
   
# Paging(페이징)
외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로,       
논리 메모리는 **Page** 로 불리는 고정 크기의 블록으로 분리한다.            
물리 메모리는 **Frame Page**라는 고정 크기로 분리한다.            
Frmae Page는 각각의 Page 와 동일한 크기로 분리되어 있고 이를 **Frame** 이라고 말한다.              

![page](https://user-images.githubusercontent.com/50267433/138475216-8c5428b0-ca76-4476-bb51-4667c7900ec9.png)

           
페이징 기법을 사용함으로써 논리 메모리의 페이지는 물리 메모리의 프레임에 저장될 때,         
**연속되어 저장될 필요가 없고** 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있다.  
이 과정에서 캐싱 알고리즘이 사용되어, Swapping을 진행한다.      
     
하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서),   
개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있다.   
       
**단점**    
* 내부 단편화 문제의 비중이 늘어나게 된다. 
    * 페이지 크기가 1,024B 이고 프로세스 A 가 3,172B 의 메모리를 요구한다면
    * 3 개의 페이지 프레임(1,024 * 3 = 3,072) 하고도 100B 가 남기때문에 총 4 개의 페이지 프레임이 필요한 것이다. 
    * 결론적으로 4 번째 페이지 프레임에는 924B(1,024 - 100)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하는 것이다.

## Segmentation(세그멘테이션)
페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 
서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) 
세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장

단점 : 
서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 
자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)
  
# 내부 단편화  
# 외부 단편화  
   
## 페이지 부재(fault)  
## 페이지 교체 알고리즘 

      
# 프로세스간의 페이지 공유
가상 메모리는...

시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 한다. 각 프로세스들은 공유 라이브러리를 자신의 가상 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가있는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다.
프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다. 이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.
fork()를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.
Demand Paging(요구 페이징)
프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라 하며, 가상 메모리 시스템에서 많이 사용된다. 그리고 가상 메모리는 대개 페이지로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다. 한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.

프로세스 내의 개별 페이지들은 페이저(pager)에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.

Page fault trap(페이지 부재 트랩)
페이지 교체
요구 페이징 에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault(페이지 부재)가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. 하지만, 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야 한다.(또는, 운영체제가 프로세스를 강제 종료하는 방법이 있다.)

기본적인 방법
물리 메모리가 모두 사용중인 상황에서의 메모리 교체 흐름이다.

디스크에서 필요한 페이지의 위치를 찾는다
빈 페이지 프레임을 찾는다.
페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다.
희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
사용자 프로세스 재시작

페이지 교체 알고리즘
FIFO 페이지 교체
가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.

장점

이해하기도 쉽고, 프로그램하기도 쉽다.
단점

오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다(초기 변수 등)
처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
Belady의 모순: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.
최적 페이지 교체(Optimal Page Replacement)
Belady의 모순을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 Belady의 모순이 발생하지 않는다. 이 알고리즘의 핵심은 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 것이다. 주로 비교 연구 목적을 위해 사용한다.

장점

알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
단점

구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.
LRU 페이지 교체(LRU Page Replacement)
LRU: Least-Recently-Used
최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

특징
대체적으로 FIFO 알고리즘보다 우수하고, OPT알고리즘보다는 그렇지 못한 모습을 보인다.
LFU 페이지 교체(LFU Page Replacement)
LFU: Least Frequently Used
참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

특징
어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다
최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.
MFU 페이지 교체(MFU Page Replacement)
MFU: Most Frequently Used
참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.

특징
최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.



# 가상메모리란?
프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있음
따라서 메모리 = 실제 + 가상 메모리라고 생각하면 안됨
메모리가 부족해서 가상메모리를 사용하는 건 맞지만, 가상메모리를 쓴다고 실제 메모리처럼 사용하는 것은 아님
실제 메모리 안에 공간이 부족하면,      
현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고,     
실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할이다.  
즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것. 이를 도와주는 것이 '가상 메모리'  

# 가상 메모리 페이징

단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요X

필요한 페이지가 있으면 나중에 자동으로 불러들어짐

외부 단편화 X

복잡한 메모리 관리로 오버헤드 발생

# 가상 메모리 세그먼테이션

필요하지 않은 세그먼트들은 로드되지 않음

필요한 세그먼트 있을때 나중에 자동으로 불러들어짐

내부 단편화X

복잡한 메모리 관리로 오버헤드 발생
