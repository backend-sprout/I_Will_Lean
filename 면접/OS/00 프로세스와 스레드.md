# 💾 프로그램

**개념 및 특징**
* 파일이 저장 장치에 저장되어 있지만 메모리에는 올라가지 않은 정적인 상태


# 📘 프로세스

**개념 및 특징**
* 실행 중인 프로그램      
* 디스크에 적재된 프로그램이 운영체제로부터 할당 받은 메모리에 적재되어 CPU를 할당 받아 작업을 수행하는 것        
* 운영체제는 독립된 메모리 영역을 `code`, `data`, `stack`, `heap` 형태로 할당해준다.  
* **독립된 메모리 영역**을 할당해 주기 때문에 프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.      
* PCB(Process Control Block)을 포함하는데 CPU를 할당받아서 작업을 처리하다가    
  다른 프로세스로 전환할 때(context switching) 프로세스의 정보를 PCB에 담아서 전달한다.

# 📗 스레드 

**개념 및 특징**  
* 프로세스 안에서 실행되는 흐름 단위     
* 쓰레드는 **레지스터와 스택을 제외한, `Code/Data/Heap` 영역을 공유한다.**    
* 한 쓰레드가 I/O 처리를 하면서 대기 상태가 되더라도 다른 쓰레드를 이용해서 읽고 쓰기 작업을 진행할 수 있다.         
* 스택을 공유하지 않는 이유는         
  함수 호출과 같은 작업을 끝내고 스택에 저장된 데이터를 비워야하는데        
  다른 쓰레드에서 공유할 경우 문제를 일으킬 수 있기 때문이다.                   
* 자원을 공유하기에 오류가 발생한다면 같은 프로세스 내의 다른 스레드 모두가 강제로 종료된다. 
        
# 🥊 프로세스와 스레드의 차이    

* 프로세스 : 독립된 메모리에 있으므로 다른 프로세스의 변수나 자료에 접근할 수 없다.   
* 스레드 : 동일한 프로세스 내에서, `code/data/heap` 영역을 공유하면서 서로다른 쓰레드들끼리 리소스 공유가 가능하다.  

# 멀티 프로세스와 멀티 스레드중 사용한다면?     
상황마다 다르겠지만, 멀티 스레드를 이용할 것 같다.          
각각의 스레드들은 메모리를 공유하는 구조이기 때문에 자원에 대한 접근이 쉽고 컨텍스트 스위칭 비용이 적어진다.  
대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제인 `Race Condition`을 해결하기 위해 '동기화'에 신경써야 한다.         
   
멀티 프로세스는 병렬로 작업이 가능하고 각 작업이 CPU를 많이 사용하는 작업일 때 성능 개선이 가능하지만   
단, 컨텍스트 스위칭이 발생하면서 생기는 오버헤드를 고려 안하면 오히려 역효과가 될 수도 있다.       

```
프로세스 컨텍스트 스위칭이 일어났을 경우, 
공유하는 데이터가 없으므로 캐쉬가 지금껏 쌓아놓은 데이터들이 무너지고 새로 캐쉬정보를 쌓아야 한다. 
반면, 쓰레드라면 저장된 캐쉬 데이터는 쓰레드가 바뀌어도 공유하는 데이터가 있으므로 의미있다. 
그러므로 컨텍스트 스위칭이 빠른 것이다. 
```

# Race Condition 
* 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태    
   
# Race Condition 해결 방법

* 상호 배제: 프로세스 P1 이 Critical Section 에서 실행중이라면, 다른 프로세스들은 그들이 가진 Critical Section 에서 실행될 수 없다.  
* 진행: Critical Section 에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보로서 참여될 수 있다.  
* 한정된 대기: P1 가 Critical Section 에 진입 신청 후 부터 받아들여질 때가지, 다른 프로세스들이 Critical Section 에 진입하는 횟수는 제한이 있어야 한다.   
  
이들을 바탕으로 뮤텍스 세마포어가 등장     
   
# 멀티 스레드 사용시 동기화 해결   
여러 방법이 있겠지만 대표적으로 2가지가 있다.   
  
1. 뮤텍스  
2. 세마포어   

# 뮤텍스
이진 세마포라고도 불리는 뮤텍스는 Lock 을 사용하는 방식으로   
임계 영역에 들어갈 때 lock을 걸어 다른 프로세스 또는 스레드가 접근하지 못하도록 하고,      
임계 영역에서 나올 때 unlock으로 대기중인 다른 프로세스 또는 쓰레드가 접근할 수 있도록 한다.    
      
# 세마포어  
임계 영역에 접근할 수 있는 스레드 또는 프로세스의 수를 제한하는 방식으로      
제한된 숫자만큼의 프로세스 또는 스레드가 접근할 수 있다.    
   
* 이진 세마포어 : 뮤텍스     
* 카운팅 세마포어 : 접근 스레드/프로세스 갯수가 2이상으로 제한된 세마포어     
   
다만, 개인적인 생각으로 동일 자원에 여러 스레드가 접근하는 것이기에      
`Version 관리`를 통해서 동시성 문제를 해결하면 되지 않을까 싶다.      

# 뮤텍스 vs 세마포어    
뮤텍스는 단일 쓰레드만 접근이 가능하기 때문에 리소스에 접근하는 쓰레드가 많으면 사용하기 어렵다.       
세마포어는 동시성 문제를 해결하지 않으면, 사용 안한것과 동일한 문제가 발생하므로 추가 관리를 해야할 것 같다. -> 버전 

즉, 본인의 계좌에서 돈을 인출하는 것과 같이 데이터의 안전성이 중요하고 여러 쓰레드가 접근 안하는 곳에서는 뮤텍스    
노션과 같은 동시에 여러 사람들이 접근하는 에디터에서는 세마포어를 사용할 것 같다.   

# 데드락 
# 데드락이 발생할 수 있는 4가지 원인   
    
* 상호 배제 : 여러 스레드가 동시에 사용 못하고, 개수가 제한적일 때
* 점유 대기 : 스레드가 자원을 점유하면 작업을 마칠때까지 점유한 자원을 내놓지 않는 것   
* 선점 불가: 스레드가 다른 스레드로부터 자원을 빼앗지 못하는 경우     
* 순환 대기 : 스레드가 필요한 자원이 서로 다른 스레드에 있는 경우    

# 데드락 해결 4가지 
                         
* 상호 배제 해결 : 자원을 여러 스레드가 동시에 사용할 수 있도록 제한된 스레드 접근 개수를 늘리는 방법(세마 포어)            
* 점유 대기 해결 : 대기를 사용하지 않는 전략으로, 필요한 자원이 있는지 먼저 파악하고 없으면 자원을 내놓고 대기함.                 
* 선점 불가 해결 : 자원이 필요할 경우 자원을 소유한 스레드에게 자원 요청을 하는 것.          
                  단, 요청받은 스레드는 자신의 자원을 풀어주고 처음부터 다시 시작한다.             
* 순환 대기 해결 : 

### 은행원 알고리즘 영상보기 -> (이거 이해 못함)         
     
# 그래서 면접 질문은? 🤔   

* 프로세스와 스레드에 대해서 설명해보세요  
* 



