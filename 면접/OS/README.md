# 오버헤드(overhead)
  
어떤 처리를 하기 위해 들어가는 간접적인 처리 시간   

# 동기/비동기        
**연관된 작업의 시작과 끝을 동일하게 가져가는지 여부이다.**    
동기일 경우, 상대의 작업이 끝났을 경우 연관된 작업을 바로 시작하는 것이고   
비동기일 경우, 상대의 작업이 끝났을 경우 연관된 작업을 시작하지 않고 나중에 시작한다.   
            
# 블록/논블락    
**제어권을 다시 받는 것을 블락/논블락 하는것**        
제어권이 블락되어있으면 상대가 작업을 마칠때까지 다른일을 하지 못하고         
제어권이 논블락되어있으면 상대의 작업 여부와 상관없이 자신의 일을 하면된다.        

# 동기/비동기/블록/논블록 조합

||Block|Non-Block|
|-|---|-----|
|Sync|Block-Sync|Non-Block-Sync|
|ASync|Block-ASync|Non-Block-ASync|
    
* 블락 동기 : 제어권을 넘겨주고 응답 받으면 연관된 작업 실행   
* 블락 비동기: 제어권을 넘겨주고 응답 받아도 연관된 작업을 나중에 실행  
* 논블락 동기: 제어권을 돌려받고 작업하다가 응답 받으면 연관된 작업 실행   
* 논블락 비동기: 제어권을 돌려받고 작업하다가 응답 받으면 연관된 작업을 나중에 실행 

# 프로세스  
메모리에 올라와 실행되고 있는 프로그램의 인스턴스     

* 운영체제는 프로세스마다 독립적인 메모리를 할당해준다.         
* 프로세스들은 독립적이기 때문에 통신하기 위해 IPC를 사용해야 한다.
* 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다   
   
# 스레드
     
프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위        
     
* 쓰레드는 Stack과 PC Register를 제외한, Code/Data/Heap 영역을 공유한다.       
* Stack을 독립적으로 할당하는 이유는          
  스레드마다 독립적인 함수 호출, 실행을 하기 위해서 독립적으로 할당한다.
  만약 공유할 경우 LIFO 순서가 뒤틀릴 수 있다.   
* PC Register 를 독립적으로 할당하는 이유는  
  컨텍스트 스위칭이 발생했을 때 쓰레드의 상태 정보를 기억하고 다시 사용하기 위해서 독립적으로 할당한다.    
* 쓰레드는 프로세스의 자원을 공유하기 때문에 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다.   

# 🥊 멀티 프로세스와 멀티 스레드   

* 멀티 프로세스 
    * 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것
    * 특징
        * 1개의 프로세스가 죽어도 자식 프로세스 이외의 다른 프로세스들은 계속 실행된다.
        * Context Switching을 위한 오버헤드(캐시 초기화, 인터럽트 등)가 발생한다.
        * 프로세스는 각각 독립적인 메모리를 할당받았기 때문에 통신하는 것이 어렵다.
        
* 멀티 쓰레드
   * 하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것
   * 특징
       * 프로세스를 위해 자원을 할당하는 시스템콜이나 Context Switching의 오버헤드를 줄일 수 있다.
       * 쓰레드는 메모리를 공유하기 때문에, 통신이 쉽고 자원을 효율적으로 사용할 수 있다.
       * 하나의 쓰레드에 문제가 생기면 전체 프로세스가 영향을 받는다.
       * 여러 쓰레드가 하나의 자원에 동시에 접근하는 경우 자원 공유(동기화)의 문제가 발생할 수 있다.

# 멀티 프로세스와 멀티 스레드중 사용한다면?     
상황마다 다르겠지만, 멀티 스레드를 이용할 것 같다.          
각각의 스레드들은 메모리를 공유하는 구조이기 때문에 자원에 대한 접근이 쉽고 컨텍스트 스위칭 비용이 적어진다.  
대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제인 `Race Condition`을 해결하기 위해 '동기화'에 신경써야 한다.         
   
멀티 프로세스는 병렬로 작업이 가능하고 각 작업이 CPU를 많이 사용하는 작업일 때 성능 개선이 가능하지만   
단, 컨텍스트 스위칭이 발생하면서 생기는 오버헤드를 고려 안하면 오히려 역효과가 될 수도 있다.       

```
프로세스 컨텍스트 스위칭이 일어났을 경우, 
공유하는 데이터가 없으므로 캐쉬가 지금껏 쌓아놓은 데이터들이 무너지고 새로 캐쉬정보를 쌓아야 한다. 
반면, 쓰레드라면 저장된 캐쉬 데이터는 쓰레드가 바뀌어도 공유하는 데이터가 있으므로 의미있다. 
그러므로 컨텍스트 스위칭이 빠른 것이다. 
```
   
# 멀티 프로세스간에 통신 IPC (Inter-Process Communication, IPC)    

1. 공유 메모리 : 프로세스끼리 규약을 정하고 데이터를 공유하는 공간(동기화 신경써야함, 빠르다)   
    1. 공유 메모리 : 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용    
    2. 메모리 맵 : 열린 파일을 메모리에 매핑   
2. 메시지 전달 시스템 : 메세지를 이용하여 통신한다. (다른 컴퓨터에도 통신가능, 느리다.)     
    1. 파이프 : 한쪽 방향으로만 통신이 가능한 반이중 통신(양방향 위해서2개 만듬)       
    2. 메시지큐 : 프로세스 중간에 존재하는 메모리 공간으로, 큐에 메시지를 보내고 이를 처리하는 기술     
    3. 소켓 : 양방향 통신이 가능한 기술로, 3way handshake로 연결 후 데이터 통신    

# Race Condition   

**개념 및 특징**
* 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태     
* 서로 다른 쓰레드들이 읽고 쓰기를 반복하면서 데이터의 정합성을 어기게 만드는 것     
      
# Race Condition 해결 방법
    
* 상호 배제 : 여러 스레드가 동시에 같은 리소스에 접근을 못하도록 한다.(스레드 갯수 제한 가능)  
* 점유 대기 : 스레드가 자원을 점유하면 작업을 마칠때까지 점유한 자원을 내놓지 않도록 한다.        
* 선점 불가 : 스레드가 다른 스레드로부터 자원을 빼앗지 못하도록 한다.          
* 순환 대기 : 스레드가 필요한 자원이 서로 다른 스레드에 있는 경우       
      
상호 배제를 기반으로 뮤텍스 세마포어가 등장     
         
# 멀티 스레드 사용시 동기화 적용 방법     
여러 방법이 있겠지만 대표적으로 2가지가 있다.   
  
1. 뮤텍스  
2. 세마포어   

# 뮤텍스
이진 세마포라고도 불리는 뮤텍스는 Lock 을 사용하는 방식으로   
임계 영역에 들어갈 때 lock을 걸어 다른 프로세스 또는 스레드가 접근하지 못하도록 하고,      
임계 영역에서 나올 때 unlock으로 대기중인 다른 프로세스 또는 쓰레드가 접근할 수 있도록 한다.    
      
# 세마포어  
임계 영역에 접근할 수 있는 스레드 또는 프로세스의 수를 제한하는 방식으로      
제한된 숫자만큼의 프로세스 또는 스레드가 접근할 수 있다.    
   
* 이진 세마포어 : 뮤텍스     
* 카운팅 세마포어 : 접근 스레드/프로세스 갯수가 2이상으로 제한된 세마포어     
   
다만, 개인적인 생각으로 동일 자원에 여러 스레드가 접근하는 것이기에      
`Version 관리`를 통해서 동시성 문제를 해결하면 되지 않을까 싶다.      

# 뮤텍스 vs 세마포어    
뮤텍스는 단일 쓰레드만 접근이 가능하기 때문에 리소스에 접근하는 쓰레드가 많으면 사용하기 어렵다.       
세마포어는 동시성 문제를 해결하지 않으면, 사용 안한것과 동일한 문제가 발생하므로 추가 관리를 해야할 것 같다. -> 버전 

즉, 본인의 계좌에서 돈을 인출하는 것과 같이 데이터의 안전성이 중요하고 여러 쓰레드가 접근 안하는 곳에서는 뮤텍스    
노션과 같은 동시에 여러 사람들이 접근하는 에디터에서는 세마포어를 사용할 것 같다.   

# 모니터 
   
뮤텍스와 비슷하지만, 프로세스가 쓰레드간의 동시성을 해결하기위해 Lock 을 거는 것   
자바의 synchronized는 모니터이다.    
   
# 데드락    
      
서로 다른 스레드가 서로가 필요로하는 자원을 가지고 있어서          
다른 스레드가 자원을 해제할 때까지 무한정 대기하고 있는 상태        
   
한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황으로,     
프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태입니다.    
    
예를 들어 다음과 같은 상황에서 데드락이 발생할 수 있습니다.    
자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때,       
P1은 B를 필요로 하고 P2는 A를 필요로 한다면      
두 프로세스 P1, P2는 서로 자원을 얻기위해 무한정 기다리게 됩니다.    

# 데드락이 발생할 수 있는 4가지 원인   
       
* 상호 배제 : 자원은 여러 스레드가 동시에 사용 못하거나 개수가 제한적인 경우 
* 점유 대기 : 스레드가 자원을 점유하면 작업을 마칠때까지 점유한 자원을 내놓지 않는 것   
* 선점 불가: 스레드가 다른 스레드로부터 자원을 빼앗지 못하는 경우     
* 순환 대기 : 스레드가 필요한 자원이 서로 다른 스레드에 있는 경우(사이클로 자원을 대기(Wait) 하고 있어야 한다)      
       
# 데드락 해결 
## 예방 4가지                           
데드락 발생 조건 중 하나를 제거하면서 해결하는 방법.      
즉, 상호 배제, 점유 대기, 비선점, 순환 대기 4가지 조건 중 하나를 제거     

## 회피(Avoidance)
데드락이 발생할 시 피해가는 방법입니다.     
대표적으로, 은행원 알고리즘을 사용하여 피해갑니다.   
  
* 은행원 알고리즘 (Banker's algorithm)
   
### 은행원 알고리즘 
데드락을 처리하기 위한 방법 중 회피에 해당하는 알고리즘.   
        
데드락에 빠질 수 있는 상태를 불안전 상태      
데드락에 빠질 수 없는 상태를 안전 상태   
            
안전 상태인 경우에만 자원을 할당해주고,       
나머지 요구들은 안전 상태가 될 때 까지 계속 거절하는 알고리즘       

<img width="999" alt="스크린샷 2020-07-05 오후 3 27 44" src="https://user-images.githubusercontent.com/50267433/138540169-3ba09d91-f55c-4379-9727-0bb8db02283c.png">
     
1. 첫번째 고객에게 15원을 빌려주고     
   첫번째 고객이 일을 해결하고 갚을 때까지 기다렸다가 다른 고객에게 돈을 빌려주는 방법

2. 두 번째 고객에게 남은 25원을 빌려주고 
   두번째 고객이 일을 해결하고 갚을 때까지 기다리는 방법    
  
3. 하지만 세번째 고객에게는 통하지 않는다.     
   은행은 25원이 남아있는데, 세번째 고객은 35원이 더 필요하기 때문이다.     
   
**돈을 빌려줄 수 있고, 다시 돈을 돌려 받을 수 있는 상태를 안전상태라고 한다.**     

**최소한 한 명에게 대출해줄 수 있는 돈을 가지고 있어야 한다는 뜻에서 나왔으며,**         
바꿔 말하면 운영체제가 최소한 하나의 프로세스가 일을 수행할 수 있는 경우에만 요청을 허락하여 시스템의 자원을 할당해주는 것과 같습니다.         
**다르게 얘기하면 최소 하나의 프로세스가 수행을 완료할 수 있을 만큼의 자원을 남겨 놓는 것을 의미한다.**       
       
안전상태 : 프로세스에게 자원을 할당했을 경우 수행을 완료할 수 있는 상태  
불안전상태 : 프로세스에게 자원을 할당했을 경우 수행을 완료할 수 없는 상태                            

단점 :     
1. 할당한 자원 수 고정     
2. 프로세스 수 고정       
3. 제한된 시간내에 자원반납 조건  
  
회피 방법은, 자원을 요청할 때마다의 시스템 상태를 판단하고 회피하는것 -> 오버헤드가 많이 발생할 수 있다.     
  
## 탐지 및 회복(Detection & Recovery)     
**자원 할당 그래프**를 통해 데드락을 감지하며,   
만약 데드락을 감지할 경우 이전 상태로 회복하는 방법       
일부러 데드락을 발생하게 놔두고 감지해서 회복하는 경우도 있습니다.     
     
예방과 회피보다 탐지 및 회복을 더 많이 사용한다.   
  
### 자원 할당 그래프     
프로세스와 자원과의 관계를 그래프로              
노드 연결상에 사이클이 발생하고        
하나의 자원에 대해 여러 프로세스가 참조를 보이면 데드락이 발생한다고 판단         

## 무시(Ignore)
  
예방 혹은 회피기법을 프로그래밍해서 넣으면 성능에 큰 영향을 미칠 수 있다.            
데드락의 발생 확률이 비교적 낮은 경우 별다른 조치를 취하지 않는다.                
만약 데드락이 발생한다 하면, 사용자가 직접 프로세스를 종료하거나 재부팅한다.   

말 그대로 데드락 발생을 무시하고 지나가는 방법입니다

# 뮤텍스 세마포어 모니터 
# 데드락 해결 방법 
# 은행원 알고리즘
# 데드락 탐지 복구 - 그래프 탐색 알고리즘 
# 가상메모리 
# 페이지 부재 
# 페이지 교체 알고리즘(락과 관련되어서 물어봄)  
