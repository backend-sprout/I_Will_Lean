# 내가 생각하는 예상질문들 


1. Array VS ArrayList 
2. Override VS Overloading
3. 동기화 방식 -> Synchronized, volatlie, Atomic클래스, Concurrent클래스 
4. ThreadLocal 
5. JVM 구성 요소
6. JIT 컴파일러란 무엇이며 어떻게 동작하는지
7. 다이나믹 메소드 디스패치(Dynamic Method Dispatch)
8. 추상 클래스 VS 인터페이스 
9. 클래스패스란, 
10. checked Exception, UncheckdException
11. Type Erasure
12. Variable Capture
13. 컬렉션 프레이웜크
14. 람다
15. 제네릭 

# 배열 VS ArrayList

1. 배열 사이즈는 고정인 반면에, ArrayList의 사이즈는 동적이다.   
2. 배열은 프리미티브 및 레퍼런스 타입 둘다 가능하지만, ArrayList는 레퍼런스타입만 가능하다.   
3. 배열은 제네릭을 사용할 수 없지만, arrayList는 타입 안정성을 보장해주는 제네릭을 사용할 수 있다.
4. 길이에 대해 배열은 length 변수를 쓰고, arrayList는 size() 메서드를 써야한다.
5. assignment(할당) 연산자를 써야하고, arrayList는 add() 메서드를 통해 element를 삽입한다.
          
ArrayList 의 초기 크기는 10이다.        
10만큼의 데이터가 다 할당되면 그 다음 입력될 때,     
일반적인 상황에서 기존의 용량 + 기존 용량/2 만큼 크기가 늘어난 배열에 기존 elementData를 copy한다.      

# 오버로딩 VS 오버라이딩
   
상위 구현체의 메서드 시그니처를 동일하게 가져갈 경우, 오버라이딩   
현 구현체에서 사용할 수 있는 메서드와 메서드 시그니처를 다르게 가져갈 경우, 오버로딩  

# Thread Local   
쓰레드마다 부여된 독립된 공간으로서     
stack 데이터가 아니지만, 다른 쓰레드들과 데이터를 공유하지 않을 때 사용    
인증, ~~~ 쪽에서 주로 사용

# JVM 구성요소 

* 클래스 로더 : 바이트 코드 읽어오기 
* 실행 엔진 : 바이트 코드 실행하기   
* 런타임 데이터 에리어 : OS로부터 할당받은 메모리 영역(JVM 자체가 하나의 프로세스니까)       
    * 힙 : 메소드 영역으로부터 생성된 객체들이 저장되는 장소, GC 대상 영역이다., 문자열 상수 풀(문자열 객체 정보)     
    * 스택 : 함수내에 존재하는 지역변수와 같은 데이터들이 저장되는 곳(공유 안 된다.)      
    * 메소드 : 클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드를 보관합니다, 런타임 상수 풀(바이트정보)   
      
* 상수풀 :  
    * Java 7 : PermGen   
    * Java 8 : Heap    
    * Heap 영역으로 변경된 이후에는 상수풀에 들어간 문자열도 Garbage Collection 대상이 된다.    
    * StringTableSize : 상수풀의 이용을 위한 hashTable, 기본크기 1009 이며 Java 11 부터는 60013
                   
# JIT 컴파일러란 무엇이며 어떻게 동작하는지                
* 인터프리터로 동작하다가 중복 발생하면(핫스팟 디텍션), 이를 `JIT Compiler -> 동일 코드 기계어`로 만듬                  
* Method inlining -> 자주 실행되는 메서드의 호출을 본문으로 대체하여 런타임시에 컴파일된 소스 코드를 최적화하는 방법    

# 다이나믹 메소드 디스패치(Dynamic Method Dispatch) 
런타임시에 타입이 결정되는 것 
  
더블 디스패치도 있는데   
런타임 디스패치를 두번 시도하는 것  
 
# 추상 클래스 VS 인터페이스   

**추상 클래스**  
* 다중 상속 안됨
* 변수 선언, 메서드 선언 가능 
* 클래스에서 추상 메서드만 선언 가능해졌다고 생각하면됨 -> 추상 메서드도 선택적이다(기술 안해도 추상 클래스 만들 수 있음)   
           
**인터페이스**       
* 다중 구현 안됨    
* 정적 상수/메서드 선언 가능, jdk9 -> private 정적 가능     
* JDK8부터 디폴트 메서드 선언 가능(불가피한 확장때 사용)     
* 추상 메서드로만 정의 가능(구현 메서드 놉)    
   
추상 클래스가 사용되는 곳은?   
1. 인스턴스 변수가 필요한 경우
2. 인터페이스의 중복이 심한 경우
3. 상태 패턴 -> State 라는 추상 클래스에, Running(), Finish() 구현 해봄
    1. Bowling -> 스페어/스타라이크/거터 -> Finish()  
    2. Bowling -> 1투구 -> Running()     
  
# Diamond Problem 
   
![112723009-d7c2fa80-8f4f-11eb-998b-da43ed8c0427](https://user-images.githubusercontent.com/50267433/138554701-2f4f0996-0480-4897-9aec-be9201b76f8b.png)
    
다중 상속을 지원할 경우 동일한 메서드 시그니처를 가진 두 클래스를 상속 받는다면? 어떤 메서드를 호출할지 모른다.   
    
하지만, 인터페이스가 다중 구현을 지원할 수 있는 이유는 메서드 구현체가 없기 때문에          
메서드 시그니처가 겹친다 하더라도 구현체에서 하나의 메서드로 구현하면 되기 때문이다.       
       
**참고로, 자바8 에서는 디폴트 메서도가 등장했는데 문제 생기는건 아닌가? 🤔**           
우선, 디폴트 메서드의 시그니처가 동일하다 하더라도 **예외적으로 하나의 메서드로 오버라이드 가능하게 해준다.**           
그리고 상위 인터페이스의 디폴트 메서드를 사용하고 싶다면, `인터페이스.super.디폴트_메소드()`로 호출하면 된다.         


# 클래스 패스    
.class 파일을 실행할 때 필요한 클래스의 경로이다.  

# checked Exception, UncheckdException

checked Exception
1. 예외처리 구문을 반드시 넣어줘야 한다.   
2. 확인 시점 -> 컴파일 타임 
3. Runtime Exception을 제외한 모든 예외
   
UncheckdException(Runtime Exception)  
1. 예외처리 구문을 안넣어줘도 된다.  
2. 확인 시점 -> 런타임 

     
# 제네릭      
제네릭 안에 타입 정보를 선언함으로써        
해당 클래스가 선언된 타입의 특성을 활용할 수 있다는 것을 명시    
즉, 타입 변환을 사용하지 않아도 해당 클래스의 메서드/변수 호출 가능   

# Type Erasure  
  
제네릭 타입정보를 컴파일 타임에만 유지하고, 런타임에는 삭제시켜 버리는 것인데  
과거 제네릭이 없던 버전과의 하위 호환성을 위해서 이러한 작업을 하는 것이다.  
    
`<T>`와 같이 일반적인 제네릭 타입 매개변수를 사용할 경우 `Object`타입으로 변형이 되고    
`<T extends SomeThing>`과 같은 바운디드 타입에서는 `SomeThing`형태로 변형이 된다.      
   
**primitve 타입은 제네릭에 사용하지 못하는 것일까? 🤔**   
이유는 바로 타입 소거(Type Erasure) 때문에 그렇다
       
타입 소거로 인하여, **런타임시에 레퍼런스 타입으로 변환되거나 Object로 변환이 되어야한다.**     
하지만, primitive 타입 같은 경우 레퍼런스 타입이 아니며, Object를 상속받지도 않는다.       

# Variable Capture





