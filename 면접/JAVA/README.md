# JVM 이란?     
                              
자바 바이트 코드를 실행해주는 버츄얼 머신으로                  
JVM을 사용하면 바이트 코드를 현재 OS 환경에 맞추어 기계어로 변역하고 실행해준다.             

# JVM 흐름 

1. 자바 파일을 작성   
2. 자바 컴파일러를 통해서 바이트 코드인 클래스파일로 생성   
3. **클래스 로더를 통해 class 파일들을 JVM으로 로딩한다.**   
4. 로딩된 class 파일들은 **실행 엔진을 통해 해석된다.(인터프리터 및 JIT compiler)**   
5. 해석된 바이트코드는 **런타임 데이터 에리어**에 배치되어 수행이 이루어진다.

# JIT Compiler   
               
인터프리터로 코드를 해석하다가.           
핫스팟 디텍션 즉, 특정 기준치만큼의 코드가 반복되면은     
코드를 캐싱하고 이후에는 캐싱된 코드를 가져다 쓰기(코드 캐시에 저장)       
 
# 런타임 데이터 에리어 
      
* PC Register : 
    * 스레드의 실행 내역 저장하고, 스레드마다 하나씩 생성된다.        
* Native Method Stack : 
    * 다른 언어로 작성된 코드를 Java Native Interface 를 통해 실행한다. 
* Class Area : 
    * 초기화 되는 대상을 저장하는 공간  
    * Runtime Constant Pool, 필드 정보, 메서드 정보, 클래스 정보, 인터페이스 정보 
* Heap : 
    * 객체들을 저장하는 공간으로, Class Area에 올라온 객체를 저장한다.(GC 범위다)    
* Stack : 
    * 지역변수와 매개변수가 저장되는 영역    
    * LIFO 구조로 동작을 하고 함수가 종료되면 스택을 비운다.     
    * 스레드마다 별도로 생성된다.    

# 자바는 인터프리터 언어? VS 컴파일 언어?    

자바는 원래는 인터프리터 언어이지만, 컴파일 언어의 특성도 가지고 있어서 하이브리드 언어이다.   

# OOP 란 무엇인가?   

* Object Oriented Programming으로 현실세계에 존재하는 논리적 개념적 개체를 객체로 표현해서 프로그래밍 하는 것    
* 객체들을 조합하고 재사용하는 방식으로 프로그래밍을 하는 것   
* 절차지향과의 차이점 :    

# 클래스와 인스턴스의 차이 
   
* 메모리 올리는 것 
* 

# OOP의 4가지 특징
  
* **추상화 :** 사물의 특징을 파악해서 이를 하나의 개념으로 다루는 것      
* **캡슐화 :** 사물의 속성과 행위를 모으고 이를 정보 은닉하는 것           
* **상속 :** 코드의 재사용 보다는, 공통된 특징을 하나의 군집화 하는 것        
* **다형성 :** 참조변수가 인스턴스에 따라 다양한 기능을 수행하는 것      

# OOP 5대 원칙 
      
* **단일 책임 원칙(SRP) :** 객체는 단 하나의 책임만 가져야 한다.(변경/사용)      
* **개방-폐쇄 원칙(OCP) :** 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.  
* **리스코프 치환 원칙(LSP) :** 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.    
* **의존 역전 원칙(DIP) :** 상위 모듈은 하위 모듈에 의존해서는 안되며 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.     
* **인터페이스 분리 원칙(ISP) :** 인터페이스가 하나의 동작만을 하도록 분리되어야 한다.   

# 자바는 Call By Value?     
자바는 Call By Value 이다.                       
**자바에서의 참조는 실제 대상이 아닌 참조 대상의 주소값을 복사하는 방식이다.**       
     
참조 변수를 메서드 인자로 넘기고 메서드 내에서 참조를 변경하더라도         
외부에 존재하는 참조 변수의 참조 대상은 바뀌지 않는다.      
즉, 대상의 값은 바뀔지 언정, 참조의 대상은 안 바뀐다.   

# Static 변수, 메소드 
  
클래스 로더가 클래스를 로딩하는 과정에서 할당되기 때문에 딱 1번만 생성된다.    
클래스 영역에 존재하며, 클래스별로 관리된다.     
  
# 가비지 컬렉션 동작 
레퍼런스 카운트 -> 원래는 원시적 -> 개선위해 트레이싱 ->   

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ws6263&logNo=100198931054   

# G1GC 종류  

# 추상 클래스와 인터페이스 설명 

* **추상 클래스 :**
    * 인스턴스 필드/메서드 선언 가능  
    * 하위 구현체는 단일 상속만 가능       
    * 인스턴스 생성 불가    
* **인터페이스** 
    * 인스턴스 필드/메서드 선언 불가능
    * 하위 구현체는 다중 구현 가능
    * static final 상수/메서드 선언 가능
    * 자바8 이후부터는 디폴트 메서드도 선언 가능    
    
# 추상 클래스와 인터페이스는 어디서 사용하느냐   
     
**추상 클래스**       
인스턴스 변수나 인스턴스 메서드가 필요할 때 사용한다.          
대표적으로 디자인 패턴의 템플릿 메서드 패턴에서 사용할 수 있다.     

템플릿 메서드 패턴은,    
인스턴스 메서드에서 추상화된 메서드를 순서대로 호출하는데   
이제 하위 클래스의 구현체에 따라, 해당 메서드의 기능을 
          
**인터페이스** 
인터페이스를 팀안에서 협의하고 정의하면             
해당 인터페이스를 표준으로 코드를 작성할 수 있다.       
함수형 인터페이스의 경우 람다가 사용 가능하고 테스트에서도 용이하다.     

# 상속 VS 구현 어느것을 원하는지   
    
상속을 사용할 경우, 하위 클래스가 상위 클래스에 의존적이게 된다.          
완벽한 is-a 관계가 아닐 경우, 불필요한 변수와 메서드를 가지게 되며           
완벽한 is-a 관계이더라도 현 클래스에 나타나지 않은 상위 클래스 요소를 확인하고 사용해야한다.   
      
그래서 최대한 인터페이스를 구현하는 위주로 코드를 작성을 할 것이며              
만약 상속하는 상위 클래스가 일반 클래스일 경우에는 컴포지션을 이용할 것이다.     
   
# 상속을 잘못 구현한 클래스는?  
         
Stack 같은 경우 벡터를 상속받는다.   
      
1. 다중 상속 불가능    
2. 싱크로나이즈드가 있어서 모든 작업에 Lock을 건다      
3. 벡터 메서드를 사용할 수 있기에, 제약 사항 깨짐   
      
# ArrayDeque (더블큐)    
  
1. 초기 용량 설정 가능  
2. 배열이 차면, 2배의 크기로 복사해서 새로 할당한다. 
  
다만 더블큐 같은 경우도 양쪽으로 값을 넣고 뺄 수 있는데      
한단계 더 나아가서 ArrayDeque을 감싸는 래퍼 클래스 즉, 일급 컬렉션을 활용해 필요한 메서드만 제공한다.   

# 자바의 싱크로나이즈드는 어떤 기법  
                  
뮤텍스는 프로세스간에 공유 객체에 대해서 사용한다.     
모니터는 프로세스내의 스레드 간의 동기화에 사용됩니다.       
프로세스내에서 동작하므로 프레임워크나 라이브러리 자체에서 제공된다.      
  
즉, 자바 싱크로나이즈드는 -> 모니터이다.
  
# final을 사용하는 클래스는 어떤 것인가?   
  
String으로 알고 있다.                          
final을 사용하는 이유를 불변으로 만들기 위해서라고 말합니다.         
만약 상속을 허용할 경우, 메서드를 통해서 상태값을 바꿀 수 있기 때문에        
final 클래스로 만들어서 상속을 막는 구조로 활용되는 것으로 알고 있습니다.  
 
# "" 와 new String()의 차이 

`""` 같은 경우 힙메모리 안에 따로 `String 상수 풀`에 저장되는걸로 알고 있다.     
그래서 만약 같은 문자열이 들어올 경우 새로 생성하지 않고, 상수풀에서 캐싱하듯이 가져온다.    

반면에 `new String()`은 호출할 때마다 힙 메모리에 새롭게 객체를 생성한다.      

## 비교 

* "abc" == "abc": true
* "abc" == new String("abc") : false

# 이퀄스랑 해시코드 재정의 해본 경험과 이유는    
VO 클래스 만들때 주로 정의한다.     
    
이퀄스를 사용하면, 커스텀한 동등성을 줄 수 있으나     
HashSet/HashMap 같은 Hash를 이용한 컬렉션 프레임워크에서는 해시코드를 이용해서 동등성판단을 하기에   
equals랑 hashcode는 같이 재정의하자   

# String의 인코딩은?   
UTF-16 -> 이것에 대해서 원인을 찾고자 했는데 못찾았다.     
Char가 2바이트인 것을 통해 알 수 있다.      
  
# Array VS List   
  
**Array**
* 
* 탐색 속도가 O(1)      
* 중간에 있는 데이터 삭제시 메모리 낭비     
* 이를 해결하고자 앞뒤로 데이터를 당기면 O(N) 복잡도 생김  
    
**List**
*
*
*
*






 
# 얕은 카피 딥카피 방법  


싱크로나이즈드 말고도 벡터의 메서드를 사용할 수 있어서 스택의 논리적 제약을 깰 수 있다는 문제가 있다.     
대신, 

