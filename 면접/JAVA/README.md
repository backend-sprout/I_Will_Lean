# JVM 이란?     
                              
자바 바이트 코드를 실행해주는 버츄얼 머신으로                  
JVM을 사용하면 바이트 코드를 현재 OS 환경에 맞추어 기계어로 변역하고 실행해준다.             

# JVM 흐름 

1. 자바 파일을 작성   
2. 자바 컴파일러를 통해서 바이트 코드인 클래스파일로 생성   
3. **클래스 로더를 통해 class 파일들을 JVM으로 로딩한다.**   
4. 로딩된 class 파일들은 **실행 엔진을 통해 해석된다.(인터프리터 및 JIT compiler)**   
5. 해석된 바이트코드는 **런타임 데이터 에리어**에 배치되어 수행이 이루어진다.

# JIT Compiler   
               
인터프리터로 코드를 해석하다가.           
핫스팟 디텍션 즉, 특정 기준치만큼의 코드가 반복되면은     
코드를 캐싱하고 이후에는 캐싱된 코드를 가져다 쓰기(코드 캐시에 저장)       
 
# 런타임 데이터 에리어 
      
* PC Register : 
    * 스레드의 실행 내역 저장하고, 스레드마다 하나씩 생성된다.        
* Native Method Stack : 
    * 다른 언어로 작성된 코드를 Java Native Interface 를 통해 실행한다. 
* Class Area : 
    * 초기화 되는 대상을 저장하는 공간  
    * Runtime Constant Pool, 필드 정보, 메서드 정보, 클래스 정보, 인터페이스 정보 
* Heap : 
    * 객체들을 저장하는 공간으로, Class Area에 올라온 객체를 저장한다.(GC 범위다)    
* Stack : 
    * 지역변수와 매개변수가 저장되는 영역    
    * LIFO 구조로 동작을 하고 함수가 종료되면 스택을 비운다.     
    * 스레드마다 별도로 생성된다.    

# 자바는 인터프리터 언어? VS 컴파일 언어?    

자바는 원래는 인터프리터 언어이지만, 컴파일 언어의 특성도 가지고 있어서 하이브리드 언어이다.   

# OOP 란 무엇인가?   

* Object Oriented Programming으로 현실세계에 존재하는 논리적 개념적 개체를 객체로 표현해서 프로그래밍 하는 것    
* 객체들을 조합하고 재사용하는 방식으로 프로그래밍을 하는 것   
* 절차지향과의 차이점 :    

# 클래스와 인스턴스의 차이 
   
* 메모리 올리는 것 
* 

# OOP의 4가지 특징
  
* **추상화 :** 사물의 특징을 파악해서 이를 하나의 개념으로 다루는 것      
* **캡슐화 :** 사물의 속성과 행위를 모으고 이를 정보 은닉하는 것           
* **상속 :** 코드의 재사용 보다는, 공통된 특징을 하나의 군집화 하는 것        
* **다형성 :** 참조변수가 인스턴스에 따라 다양한 기능을 수행하는 것      

# OOP 5대 원칙 
      
* **단일 책임 원칙(SRP) :** 객체는 단 하나의 책임만 가져야 한다.(변경/사용)      
* **개방-폐쇄 원칙(OCP) :** 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.  
* **리스코프 치환 원칙(LSP) :** 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.    
* **의존 역전 원칙(DIP) :** 상위 모듈은 하위 모듈에 의존해서는 안되며 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.     
* **인터페이스 분리 원칙(ISP) :** 인터페이스가 하나의 동작만을 하도록 분리되어야 한다.   

# 자바는 Call By Value?     
자바는 Call By Value 이다.                       
**자바에서의 참조는 실제 대상이 아닌 참조 대상의 주소값을 복사하는 방식이다.**       
     
참조 변수를 메서드 인자로 넘기고 메서드 내에서 참조를 변경하더라도         
외부에 존재하는 참조 변수의 참조 대상은 바뀌지 않는다.      
즉, 대상의 값은 바뀔지 언정, 참조의 대상은 안 바뀐다.   

# Static 변수, 메소드 
  
클래스 로더가 클래스를 로딩하는 과정에서 할당되기 때문에 딱 1번만 생성된다.    
클래스 영역에 존재하며, 클래스별로 관리된다.     
  
# 가비지 컬렉션 동작 
레퍼런스 카운트 -> 원래는 원시적 -> 개선위해 트레이싱 ->   

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ws6263&logNo=100198931054   

# G1GC 종류  

# 추상 클래스와 인터페이스 설명 

* **추상 클래스 :**
    * 인스턴스 필드/메서드 선언 가능  
    * 하위 구현체는 단일 상속만 가능       
    * 인스턴스 생성 불가    
* **인터페이스** 
    * 인스턴스 필드/메서드 선언 불가능
    * 하위 구현체는 다중 구현 가능
    * static final 상수/메서드 선언 가능
    * 자바8 이후부터는 디폴트 메서드도 선언 가능    
    
# 추상 클래스와 인터페이스는 어디서 사용하느냐   
   
추상클래스는 디자인 패턴에서 주로 사용하는 것 같다.         
템플릿 메서드 패턴이나, 상태 패턴에서 주로 사용한다.      
        
인터페이스를 지정하면, 팀 컨벤션에 도움이 될 수 있다.     
   
# 상속 VS 구현 어느것을 원하는지   
    
상속을 사용할 경우, 하위 클래스가 상위 클래스에 의존적이게 된다.          
완벽한 is-a 관계가 아닐 경우, 불필요한 변수와 메서드를 가지게 되며           
완벽한 is-a 관계이더라도 현 클래스에 나타나지 않은 상위 클래스 요소를 확인하고 사용해야한다.   
      
그래서 최대한 인터페이스를 구현하는 위주로 코드를 작성을 할 것이며              
만약 상속하는 상위 클래스가 일반 클래스일 경우에는 컴포지션을 이용할 것이다.    


