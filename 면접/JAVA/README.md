# JVM 이란?     
                              
자바 바이트 코드를 실행해주는 버츄얼 머신으로                  
JVM을 사용하면 바이트 코드를 현재 OS 환경에 맞추어 기계어로 변역하고 실행해준다.             

# JVM 흐름 
 
1. 자바 파일을 작성     
2. 자바 컴파일러를 통해서 바이트 코드인 클래스파일로 생성     
3. **클래스 로더를 통해 class 파일들을 JVM으로 로딩한다.**    
4. 로딩된 class 파일들은 **실행 엔진을 통해 해석된다.(인터프리터 및 JIT compiler)**      
5. 해석된 바이트코드는 **런타임 데이터 에리어(프로세스로부터 할당 받은 메모리)**에 배치되어 수행이 이루어진다.   

# JIT Compiler   
                  
인터프리터로 코드를 해석하다가.           
핫스팟 디텍션 즉, 특정 기준치만큼의 코드가 반복되면은     
코드를 캐싱하고 이후에는 캐싱된 코드를 가져다 쓰기(코드 캐시에 저장)       
 
# 런타임 데이터 에리어 
      
* PC Register : 
    * 스레드의 실행 내역 저장하고, 스레드마다 하나씩 생성된다.        
* Native Method Stack : 
    * 다른 언어로 작성된 코드를 Java Native Interface 를 통해 실행한다. 
* Class Area : 
    * 초기화 되는 대상을 저장하는 공간  
    * Runtime Constant Pool, 필드 정보, 메서드 정보, 클래스 정보, 인터페이스 정보 
* Heap : 
    * 객체들을 저장하는 공간으로, Class Area에 올라온 객체를 저장한다.(GC 범위다)    
* Stack : 
    * 지역변수와 매개변수가 저장되는 영역    
    * LIFO 구조로 동작을 하고 함수가 종료되면 스택을 비운다.     
    * 스레드마다 별도로 생성된다.    

# 자바는 인터프리터 언어? VS 컴파일 언어?    

자바는 원래는 인터프리터 언어이지만, 컴파일 언어의 특성도 가지고 있어서 하이브리드 언어이다.   

# OOP 란 무엇인가?   

* Object Oriented Programming으로 현실세계에 존재하는 논리적 개념적 개체를 객체로 표현해서 프로그래밍 하는 것      
* 자동차 프레임 객체 + 타이어 -> 자동차
* 오토바이 프레임 객체 + 타이어 -> 오토바이
* 자동차 프레임 객체 + 겨울용 타이어 -> 자동차긴하지만 기능 다름  

# 클래스와 인스턴스의 차이 
         
* 클래스 사물에 대한 개념이자 틀        
* 객체는 클래스 정보를 기반으로 실제 메모리상에서 구현된 인스턴스      

# OOP의 4가지 특징
  
* **캡슐화 :** 사물의 속성과 행위를 모으고 이를 정보 은닉하는 것           
* **상속 :** 코드의 재사용 보다는, 공통된 특징을 하나의 군집화 하는 것        
* **추상화 :** 사물의 특징을 파악해서 이를 하나의 개념으로 다루는 것      
* **다형성 :** 참조변수가 인스턴스에 따라 다양한 기능을 수행하는 것      

# OOP 5대 원칙 
      
* **단일 책임 원칙(SRP) :** 객체는 단 하나의 책임만 가져야 한다.(변경/사용)      
* **개방-폐쇄 원칙(OCP) :** 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.  
* **리스코프 치환 원칙(LSP) :** 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.    
* **인터페이스 분리 원칙(ISP) :** 인터페이스가 하나의 동작만을 하도록 분리되어야 한다.   
* **의존 역전 원칙(DIP) :** 상위 모듈은 하위 모듈에 의존해서는 안되며 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.     
   
# 자바는 Call By Value?     
자바는 Call By Value 이다.                       
**자바에서의 참조는 실제 대상이 아닌 참조 대상의 주소값을 복사하는 방식이다.**       
     
참조 변수를 메서드 인자로 넘기고 메서드 내에서 참조를 변경하더라도         
외부에 존재하는 참조 변수의 참조 대상은 바뀌지 않는다.      
즉, 대상의 값은 바뀔지 언정, 참조의 대상은 안 바뀐다.   

# Static 변수, 메소드 
  
클래스 로더가 클래스를 로딩하는 과정에서 할당되기 때문에 딱 1번만 생성된다.    
클래스 영역에 존재하며, 클래스별로 관리된다.     
  
# 가비지 컬렉션 동작 
   
1. 객체들은 Eden 영역에 생성되다가 꽉 차면 GC 시작        
2. STW : GC 쓰레드를 제외한 모든 쓰레드의 실행을 멈춘다.        
3. GC 발생    
    **GC 알고리즘 2개**      
    * 레퍼런스 카운팅         
        * 객체를 참조하는 레퍼런스의 숫자를 저장하는데 이 숫자가 0이 되면 메모리를 해제한다.         
        * 구현이 쉽지만, 순환참조에서는 GC를 발생시키지 못한다.       
    * 마크앤 스왑    
        * 객체 그래프 탐색을 통해 현재 참조되고 있는 객체에 마킹  
        * 마킹이 되지 않는 객체들은 더이상 사용하지 않는다고 판단하여 메모리 해제    
4. 살아남은 객체를 Survivor 영역에 옮기고 Age 1 증가     
5. 이같은 작업을 반복      
6. age가 특정 기준치 이상이 되면 Old 로 옮긴다.   
   
# Young 과 Old로 나눈 이유
* young Generation은 자주 발생 + 삭제되는 데이터 많음
* Old Generation은 간혹 발생 + 삭제되는 데이터 적음
  
객체들은 생성 시간에 따라 비슷한 영역/지역에 뭉쳐져 있다.  
하지만, 이러한 특징을 고려하지 않고 마킹을 위해 메모리를 풀스캔할 경우 이는 성능저하를 유발한다.   
  
* OLD + Young가 하나의 영역이라면 전체 영역을 순회해야함  
* OLD 한 객체들은 계속 살아있으므로 객체 그래프 탐색 지속적으로 이루어짐   
* 그래프 탐색 시간 길어짐에 따라 STW 도 길어지고 이로인해 성능 저하   

# G1GC 종류  

* Serial GC
* Parallel GC
* Parallel Old GC(Parallel Compacting GC)
* Concurrent Mark & Sweep GC(이하 CMS)
* G1GC (Garbage First GC)   
* ZGC (추가 예정)     

# 추상 클래스와 인터페이스 설명 

* **추상 클래스 :**
    * 인스턴스 필드/메서드 선언 가능  
    * 하위 구현체는 단일 상속만 가능       
    * 인스턴스 생성 불가    
* **인터페이스** 
    * 인스턴스 필드/메서드 선언 불가능
    * 하위 구현체는 다중 구현 가능
    * static final 상수/메서드 선언 가능
    * 자바8 이후부터는 디폴트 메서드도 선언 가능    
    
# 추상 클래스와 인터페이스는 어디서 사용하느냐   
     
**추상 클래스**       
인스턴스 변수나 인스턴스 메서드가 필요할 때 사용한다.          
대표적으로 디자인 패턴의 템플릿 메서드 패턴에서 사용할 수 있다.     

템플릿 메서드 패턴은,    
인스턴스 메서드에서 추상화된 메서드를 순서대로 호출하는데   
이제 하위 클래스의 구현체에 따라, 해당 메서드의 기능을 
          
**인터페이스** 
인터페이스를 팀안에서 협의하고 정의하면             
해당 인터페이스를 표준으로 코드를 작성할 수 있다.       
함수형 인터페이스의 경우 람다가 사용 가능하고 테스트에서도 용이하다.     

# 상속 VS 구현 어느것을 원하는지   
    
상속을 사용할 경우, 하위 클래스가 상위 클래스에 의존적이게 된다.          
완벽한 is-a 관계가 아닐 경우, 불필요한 변수와 메서드를 가지게 되며           
완벽한 is-a 관계이더라도 현 클래스에 나타나지 않은 상위 클래스 요소를 확인하고 사용해야한다.   
      
그래서 최대한 인터페이스를 구현하는 위주로 코드를 작성을 할 것이며              
만약 상속하는 상위 클래스가 일반 클래스일 경우에는 컴포지션을 이용할 것이다.     
   
# 상속을 잘못 구현한 클래스는?  
         
Stack 같은 경우 벡터를 상속받는다.   
      
1. 다중 상속 불가능    
2. 싱크로나이즈드가 있어서 모든 작업에 Lock을 건다      
3. 벡터 메서드를 사용할 수 있기에, 제약 사항 깨짐   
      
# ArrayDeque (더블큐)    
  
1. 초기 용량 설정 가능  
2. 배열이 차면, 2배의 크기로 복사해서 새로 할당한다. 
  
다만 더블큐 같은 경우도 양쪽으로 값을 넣고 뺄 수 있는데      
한단계 더 나아가서 ArrayDeque을 감싸는 래퍼 클래스 즉, 일급 컬렉션을 활용해 필요한 메서드만 제공한다.   

# 자바의 싱크로나이즈드는 어떤 기법  
                  
뮤텍스는 프로세스간에 공유 객체에 대해서 사용한다.     
모니터는 프로세스내의 스레드 간의 동기화에 사용됩니다.       
프로세스내에서 동작하므로 프레임워크나 라이브러리 자체에서 제공된다.      
  
즉, 자바 싱크로나이즈드는 -> 모니터이다.
  
# final을 사용하는 클래스는 어떤 것인가?   
  
String으로 알고 있다.                          
final을 사용하는 이유를 불변으로 만들기 위해서라고 말합니다.         
만약 상속을 허용할 경우, 메서드를 통해서 상태값을 바꿀 수 있기 때문에        
final 클래스로 만들어서 상속을 막는 구조로 활용되는 것으로 알고 있습니다.  
 
# "" 와 new String()의 차이 

`""` 같은 경우 힙메모리 안에 따로 `String 상수 풀`에 저장되는걸로 알고 있다.     
그래서 만약 같은 문자열이 들어올 경우 새로 생성하지 않고, 상수풀에서 캐싱하듯이 가져온다.    

반면에 `new String()`은 호출할 때마다 힙 메모리에 새롭게 객체를 생성한다.      

## 비교 

* "abc" == "abc": true
* "abc" == new String("abc") : false

# 이퀄스랑 해시코드 재정의 해본 경험과 이유는    
VO 클래스 만들때 주로 정의한다.     
    
이퀄스를 사용하면, 커스텀한 동등성을 줄 수 있으나     
HashSet/HashMap 같은 Hash를 이용한 컬렉션 프레임워크에서는 해시코드를 이용해서 동등성판단을 하기에   
equals랑 hashcode는 같이 재정의하자   

# 해시맵, 해시테이블 차이
   
* HashMap : 주요 메소드에 synchronized 키워드가 없습니다. key, value에 null을 입력할 수 있습니다.  
* HashTable : 주요 메소드에 synchronized 키워드가 선언, key, value 에 null을 입력할 수 없습니다.  
* ConcurrentHashMap의 : HashMap을 thread-safe 하도록 만든 클래스가 ConcurrentHashMap입니다.    
단, key, value 에 null을 입력할 수 없으며 putIfAbsent라는 메소드 가집니다.     
   
# String의 인코딩은?   
UTF-16 -> 이것에 대해서 원인을 찾고자 했는데 못찾았다.     
Char가 2바이트인 것을 통해 알 수 있다.      
         
# Array VS ArrayList 
   
**Array**   
* 크기가 고정되어 있다.  
* 메모리에 연속적으로 들어가 있다.   
* 탐색시 속도가 `O(1)`        
* 중간에 존재하는 데이터 추가 삭제시 최악의 경우 `O(N)` 발생  
   
**List**      
* 크기가 동적이다.     
* 메모리가 연속적이지 않다.    
* 일반 배열에 없는 컬렉션 메서드를 지원한다.   
* 중간에 데이터를 추가 또는 삭제시 
    * 맨 앞이라면 O(1) 
    * 맨 뒤라면 O(N)    

**ArrayList**      
* 크기가 동적이다.     
* 메모리가 연속적이다.     
* add 되었을 경우 시간복잡도는 O(1)이다.    
    * 기본 사이즈는 10이고, 그 이상 add 될경우 복사후 새로 메모리를 할당한다.       
    * 이때, 시간복잡도를 O(N)으로 생각할 수 있는데 빈도수가 적어서 그냥 O(1)로 처리한다.   

# add vs offer / remove vs poll 
   
**익셉션 발생**
* add : Exception  
* remove : Exception  
* element : Exception 

**널 반환**
* offer : null
* poll : null  
* peek : null

# Serializable   
   
시리얼 라이저블 -> 외부에서도 통신할때 -> 객체 자체를 통신하고 싶을때
JVM에 올리면 -> 분석해서 ->

시리얼라이저블 -> 마커 인터페이스 -> 구현된 메서드는 JVM에서 컴파일할때
-> 직렬화가 가능한 애라고 JVM에게 알리는거 -> 인터페이스 다중 구현가능하니 이 메커니즘 이용


시리얼라이즈버전 -> 직렬화 -> 안에 필드값을 바꾸거나 다르게 되면 -> 다른 객체로 인식 -> 필드에 네임이랑 아이디만 만듬 -> 추가로 어드레스 선언(변수3) SerializableId ->


# 쉘로우 카피와 딥카피 설명
  
얕은 복사 : A라는 객체를 복사했을 때 내부에 구현되어 있는 참조변수들의 참조값도 그대로 복사한다.      
깊은 복사 : A라는 객체를 복사했을 때 내부에 구현되어 있는 참조변수들의 참조값도 달라진다.       
  
# 쉘로우 카피 방법 
  
* Collections.copy()  
* @Cloneable with super.clone()  

# 딥카피 방법 
* System.arraycopy();

# JDK 버전별 특징 

* JDK 8: 
    * 인터페이스 - default 메서드
    * 인터페이스 - static 메서드
    * try-with-resource : 괄호안에 변수 선언해야함 
* JDK 9: 
    * 인터페이스 - private 선언 가능(default/static) 
    * try-with-resource : 괄호 밖, 실질적인 final 변수 가능 
    * List.of()와 같은 컬렉션 프레임워크 팩토리 메서드 제공(불변 컬렉션)
    * Arrays - Arrays.compare(a,b), 배열의 논리적 순서반환(-1 a빠름, 0 ab같음, 1 b빠름)
    * Arrays - Arrays.missmatch(a,b), 배열비교시 다른 첫번째 인덱스 반환  
* JDK 10:
    * var 타입 추가 
* JDK 11: 
    * String인스턴스.isBlank() - 공백문자로만 이루어졌는지 판단   
    * String인스턴스.lines() - 개행 제거해서 stream 돌림
    * String인스턴스.repeat(10) - 해당문자열을 반복해서 더한 문자열 반환
    * String인스턴스.strip() - 공백문자에 해당하는 앞뒤를 제거 
    * Files.writeString() - 문자열을 파일로 저장 가능
    * Files.readString() - 파일에서 문자열 읽기 가능 
* JDK 12:
    * indent(int n) - 숫자만큼 들여쓰기(양수 들여스기, 음수 내어쓰기)   
    * "".transform(람다) - 문자열을 다른걸로 바꾸는 함수를 넣을 수 있음 
* JDK 14:
    * switch - 식으로 사용할 때, 화살표 함수 및 반환 기능 제공   
* JDK 15: 
    * text블록 : `""" 내용 """`를 이용하면 벡틱 처럼 텍스트 블록 가능 
    * "".formatted() : String.format() 대타  
    * NPE 메시지 (누가 널인지 알려줌)   
* JDK 16: 
    * stream - toList() -> Collectors.toList() 대신
    * stream - mapMulti() -> 값을 하나를 받아서 여러개 생성 가능    
    * instanceOf 패턴 매칭 
    * record 클래스 - 코틀린의 value 클래스 같은 클래스(VO만들때 좋다.)   
    

