# HTTP 의 문제점
* HTTP 는 평문 통신이기 때문에 도청이 가능하다.     
* 통신 상대를 확인하지 않기 때문에 위장이 가능하다.      
* 내용의 정확성을 증명할 수 없기 때문에 변조가 가능하다.      
       
## TCP/IP 는 도청 가능한 네트워크이다.
TCP/IP 구조의 통신은 **경로 상에서 패킷을 엿볼 수 있기에 패킷을 수집하는 것만으로 도청할 수 있다.**      
평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 **암호화하여 통신해야 한다.**     
                 
## HTTP는 통신 상대를 확인하지 않기 때문에 위장이 가능하다.     
HTTP 통신에는 **송수신자를 확인하는 작업이 없기 때문에 누구든지 리퀘스트/리스폰스를 보낼 수 있다.**   
       
1. 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할 수 없다.
2. 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다.
3. 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.
4. 어디에서 누가 리퀘스트 했는지 확인할 수 없다.
5. 의미없는 리퀘스트도 수신한다. —> DoS 공격을 방지할 수 없다
   
## 완전성을 증명할 수 없기 때문에 변조가 가능하다
**'서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다'라는 것을 보장할 수 없다.**        
통신하는 과정에서 누군가에 의해 변조되더라도 이 사실을 알 수 없다.           
공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 **중간자 공격(Man-in-the-Middle)** 이라고 부른다.     
           
## 해결방법  
HTTP 프로토콜에 암호화 프로토콜인 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security)를 조합하면 된다.   
SSL/TLS는 **통신 내용을 암호화**, **송수신자 인증**, **다이제스트 기능**을 제공하고 있다.        
이렇듯 HTTP 프로토콜에 암호화 프로토콜인 SSL을 조합한 것을 `HTTPS(HTTP Secure)` 또는 `HTTP over SSL`이라고 부른다          
         
# HTTPS 
HTTP 에 **암호화**와 **인증** 그리고 **완전성 보호**를 더한 프로토콜을 HTTPS 라고 부른다.   

![http-1-14](https://user-images.githubusercontent.com/50267433/138423993-cea44886-cb35-4fc1-ae56-64320b6ee7b8.png)
       
HTTP 통신하는 소켓 부분을 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 프로토콜로 대체하는 것 뿐이다.    
HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 SSL 이 TCP 와 통신 하게 된다.  
SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.

![ssl 통신](https://user-images.githubusercontent.com/50267433/138454378-20513421-4960-4e56-889d-72c749e009f7.png)

HTTPS 의 SSL 에서는 **공통키 암호화 방식**과 **공개키 암호화 방식**을 혼합한 **하이브리드 암호 시스템을 사용한다.**       
공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다.  
     
1. 공개키 방식으로 통신을 먼저하면, 공통키 줌
2. 공통키로 암호를 사용  

좀더 세부적인 프로세스는 아래와 같다.   

1. **클라이언트 :** `랜덤값` + `브라우저가 적용할 수 있는 암호화 방식 후보 리스트` 전달    
2. **서버 :** `랜덤값` + `클라이언트가 보낸 리스트중 적용 가능한 암호화 방식 1개 채택` + `SSL CA 인증서` 전달  
3. **클라이언트 :** CA가 올바른지 확인, **CA에 담긴 Public key로 pre master secret을 암호화해서 요청**   
4. **서버 :** Private key로 해독한 후, 앞으로 사용할 **대칭키**를 만들고 클라이언트에게 전달
5. **이후부터 :** 클라이언트와 서버간에 대칭키를 통해서 통신  

## 하이브리드 암호화를 적용한 이유는?   
  
* 대칭키
    * 한 개의 key로 암호화 복호화
    * 속도가 빠르다.
    * 탈취의 위험이 있다.
* 비대칭키 (공개키, 비밀키)
    * 공개키로 암호화, 비밀키로 복호화
    * 속도가 느리다.
    * 인증의 기능까지 제공한다.

대칭키의 장단점과 비대칭키의 장단점을 흡수하고자 해서이다.     
   
# 모든 웹 페이지에서 HTTPS를 사용해도 될까?  
평문 통신에 비해서 **암호화 통신은 `CPU`나 `메모리` 등 리소스를 더 많이 요구한다.**      
즉, 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에     
**서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 된다.**   
        
하지만 최근에는 **하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며,**         
새로운 표준인 **HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다.**        
현재는 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.      
  
# SSL
# TLS 

네스케이프에 의해서 SSL이 발명되었고,   
이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다.   
TLS 1.0은 SSL 3.0을 계승한다.   
하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.  

# 대칭키
   
대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 암호화 기법을 의미한다.     
즉 **1234 key**로 암호화 했으면 복호화 할 때도 **1234 key** 값으로 해야 한다.     

# 공개키      
공개키 방식은 두개의 키를 갖는다.      
   
* A키로 암호화를 하면 B키 복호화 할수 있고,   
* B키로 암호화했다면 A키로 복호화 할 수 있다.   

두개의 키 중 **하나를 비공개키(개인키, 비밀키)** 라 하고 나머지를 **공개키** 라고 한다.   
비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다.   
     
타인은 공개키를 이용해서 정보를 암호화한다.    
암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다.     
      
비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다.     
공개키가 유출된다고 하더라도 비공개키를 모르면 정보를 생성 수 없기 때문에 안전하다.    

비공개키의 소유자는 비공개키를 이용해서 정보를 암호환 후에 공개키와 함께 암호화된 정보를 전송한다.   
정보와 공개키를 획득한 사람은 공개키를 이용해서 암호화된 정보를 복호화한다.      
       
암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은       
그 데이터가 공개키와 쌍을 이루는 비공개 키에 의해서 암호화 되었다는 것을 의미한다.       
즉 공개키가 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다.       

# 참고 
* https://cheese10yun.github.io/https/
* https://12bme.tistory.com/80
* https://velog.io/@moonyoung/HTTPS%EC%9D%98-%EC%9B%90%EB%A6%AC
* https://www.ibm.com/docs/ko/i/7.1?topic=concepts-supported-ssl-transport-layer-security-protocols
