# OSI 7 Layer
통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약
   
* **물리 :** 전송하는데 필요한 기능을 제공 ( 통신 케이블, 허브 )
* **데이터링크 :** 송/수신 확인. MAC 주소를 가지고 통신함 ( 브릿지, 스위치 )
* **네트워크 :** 패킷을 네트워크 간의 IP를 통해 데이터 전달 ( 라우팅 )
* **전송 :** 두 host 시스템으로부터 발생하는 데이터 흐름 제공
* **세션 :** 통신 시스템 사용자간의 연결을 유지 및 설정함
* **표현 :** 세션 계층 간의 주고받는 인터페이스를 일관성있게 제공
* **응용 :** 사용자가 네트워크에 접근할 수 있도록 서비스 제공

내가 정리한 다른 글을 참고하면서 다시 정리하자   

# TCP/IP 4계층 

* LINK 계층 : 
    * 물리적인 영역의 표준화에 대한 결과
    * 가장 기본이 되는 영역으로 LAN, WAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역이다

* IP 계층 : 
    * 경로 검색을 해주는 계층임
    * IP 자체는 비연결지향적이며, 신뢰할 수 없는 프로토콜이다
    * 데이터를 전송할 때마다 거쳐야할 경로를 선택해주지만, 경로가 일정하지 않음.    
      또한 데이터 전송 중에 경로상 문제가 발생할 때 데이터가 손실되거나 오류가 발생하는 문제가 발생할 수 있음.     
      따라서 IP 계층은 오류 발생에 대한 대비가 되어있지 않은 프로토콜임   
* TCP/UDP (전송) 계층 : 
    * 데이터의 실제 송수신을 담당함
    * UDP는 TCP에 비해 상대적으로 간단하고, TCP는 신뢰성잇는 데이터 전송을 담당함
    * TCP는 데이터 전송 시, IP 프로토콜이 기반임 (IP는 문제 해결에 문제가 있는데 TCP가 신뢰라고?) → IP의 문제를 해결해주는 것이 TCP인 것. 
    * 데이터의 순서가 올바르게 전송 갔는지 확인해주며 대화를 주고받는 방식임. 이처럼 확인 절차를 걸치며 신뢰성 없는 IP에 신뢰성을 부여한 프로토콜이 TCP이다

* 애플리케이션 계층 : 
    * 서버와 클라이언트를 만드는 과정에서 프로그램 성격에 따라 데이터 송수신에 대한 약속들이 정해지는데, 이것이 바로 애플리케이션 계층이다


# TCP란?
서버와 클라이언트의 함수 호출 순서가 중요하다

서버 : socket() 생성 → bind() 소켓 주소할당 → listen() 연결요청 대기상태 → accept() 연결허용 → read/write() 데이터 송수신 → close() 연결종료

클라이언트 : socket() 생성 → connect() 연결요청 → read/write() 데이터 송수신 → close() 연결종료

둘의 차이는?
클라이언트 소켓을 생성한 후, 서버로 연결을 요청하는 과정에서 차이가 존재한다.

서버는 listen() 호출 이후부터 연결요청 대기 큐를 만들어 놓고, 그 이후에 클라이언트가 연결 요청을 할 수 있다. 이때 서버가 바로 accept()를 호출할 수 있는데, 연결되기 전까지 호출된 위치에서 블로킹 상태에 놓이게 된다.

이처럼 연결지향적인 TCP는 신뢰성 있는 데이터 전송이 가능함 (3-way handshaking)

흐름제어와 혼잡제어를 지원해서 데이터 순서를 보장해줌

흐름제어 : 송신 측과 수신 측의 데이터 처리 속도 차이를 조절해주는 것

혼잡 제어 : 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것

정확성 높은 전송을 하기 위해 속도가 느린 단점이 있고, 주로 웹 HTTP 통신, 이메일, 파일 전송에 사용됨
