# DB 용어 설명 

* DB : 
* Table : 행과 열로 구성된 여러 데이터셋의 모음 
* 컬럼 : 
* 로우 : 

# 인덱스란? 

인덱스랑 테이블에 저장되어 있는 데이터를 빠르게 조회하기 위해서 설계된 자료구조         
흔히 비유하자면 책에 있는 색인 역할로 원하는 데이터를 빠르게 찾아주는 역할을 하고 있습니다.      

# Index 자료구조  
> 그렇다면 DBMS 는 인덱스를 어떻게 관리하고 있는가    
     
**해시 테이블**  
* 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.
* 시간복잡도가 O(1)이라 검색이 매우 빠르다.
* 부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.

**B+Tree** 
* 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.
* B-Tree의 리프 노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.
* 해시 테이블보다 나쁜 O(log2n) 의 시간복잡도를 갖지만 해시테이블보다 흔하게 사용된다.

# 왜 index 를 생성하는데 b-tree 를 사용하는가?
>데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데?       
      
SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 된다.     
hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다.       
동등 연산(=)에 특화된 `hashtable`은 데이터베이스의 자료구조로 적합하지 않다.     
    
# 인덱스는 어떤 컬럼에 사용할 것이냐    

저장이 덜 일어나고 조회가 자주 일어나는 컬럼이라는 얘기도 맞지만   
인덱스의 종류에 따라 다르다고 생각을 한다.
        
클러스터드 인덱스 같은 경우,       
key 값이 정렬되어 있고       
공간 지역성의 특징으로 연관된 데이터가 모여있을 가능성이 높으므로 범위 탐색에 유용하다.     
     
논클러스터드 인덱스의 경우      
카디널리티가 높을 수록 인덱스 설정에 좋은 컬럼입니다.






# 트랜잭션 

트랜잭션이란 하나의 논리적 작업 단위이다.          
트랜잭션 안에는 여러 쿼리문이 존재할 수 있고      
이들의 실행이 모두 완료되어야 비로소 하나의 작업이 완료되었다고 판단한다.   
      
대표적으로 UPDATE를 예시로 들 수 있을 것 같습니다.       
UPDATE 같은 경우 find를 하고 update 를 하는 쿼리가 2번 나가지만    
이 작업을 모두 완료해야 하나의 작업이 완료되었다고 말할 수 있을 것 같습니다.  
  
# 트랜잭션 특징 4가지 
     
* **Atomic :** 모든 세부 작업들이 완료되어야 완료되고, 하나라도 실패하면 다 실패해야한다.     
* **Consistency :** 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야한다(무결성 제약 조약 조건을 만족해야한다.)    
* **Isolation :** 트랜잭션이 동작을 할때 다른 트랜잭션의 간섭을 받지 않아야한다.     
* **Dulablity :** 커밋이 완료되면 해당 데이터는 DB에 지속적으로 반영이 되어야한다.    
       
# 트랜잭션 고립 레벨 4가지    
1. read uncommitted : 
    * 커밋되기전의 데이터를 읽을 수 있다. 
    * **Dirty Read :** 롤백이되는데 다른 트랜잭션에서 그 값을 그대로 가지고 있을 수 있다.   
2. read committed : 
    * 대부분의 DB가 제공해주는 레벨이다.   
    * 커밋된 이후의 데이터만 읽을 수 있다.   
    * **UnRepeatable Read :** 데이터를 읽었는데 도중에 또 커밋이 일어나면 데이터의 불일치가 발생한다.   
3. repeatable read :      
    * 트랜잭션이 종료될 때까지 한번 조회한 데이터를 반복해서 조회한다.       
    * **Phantom Read :** 데이터베이스는 로우 단위로 락을 걸기 때문에, 새로 추가되거나 삭제된 락에 대해서는 처리를 못한다.     
4. serializable :  
    * 트랜잭션이 종료될 때까지 다른 트랜잭션의 접근을 막는다.  
    
# 트랜잭션과 락
  
락은 동시성에 대한 문제    
트랜잭션은 정합성에 대한 문제    
      
* 락이 없다면? -> 값이 변경되더라도 트랜잭션은 성공한다.      
* 트랜잭션이 없다면? -> 데이터가 도중에 실패해도 동시성은 해결한다.  

# 락 방식
## 낙관적 락
JPA 에서는 Version 방식을 지원해서, 커밋에 따른 버전관리를 해준다.   
자바에서는 volatile 과 atomic 방식을 예시로 들 수 있다.      
     
## 비관적 락   









인덱스 트랜잭션 DB ACID

/// 이거 솔직히 첨듣습니다 /// 자료구조? -> 트리 -> BBST -> RED/BLACK 트리 / AVL 트리 / /////////////////////////////////

샤딩 레플리케이션 리피티드 리드 커밋티드 실행계획

/// 몽고디비 샤딩전략? ->아뉘.. ///

///

레디스 마스터 설정 알고리즘 아뉘 레디스가 어떤 형태를 가지고 있는지

싱글 스레드 ->

왜 사용했는지만 -> 채팅에 썼으니까 -> 레디스 -> ///

stable 차이 unstable sort 차이
