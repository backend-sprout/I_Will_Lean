# 1. 인덱스란 무엇인가?   
   
인덱스란 사전적 정의로 검색을 위해 임의의 규칙대로 부여된 임의의 대상을 가리키는 무언가입니다.        
좀 더 쉽게 비유하자면 책의 맨처음이나 마지막에 있는 색인과 같은 역할이라고 생각하면 될 것 같습니다.     
         
책에도 색인이 없다면 원하는 내용을 찾기 위해서 모든 페이지를 찾아 봐야 되듯이     
데이터베이스도 인덱스가 없다면 원하는 데이터를 찾기 위해서 (풀 스캔, 풀테이블 스캔)을 진행해야합니다.(레인지 스캔)      
   
다시 말하면, 인덱스를 이용하면 원하는 데이터를 비교적 빠르게 찾을 수 있다는 장점이 있습니다.  
대신 별도의 저장공간을 만들어 한다 -> 10퍼센트 정도  



# 2. 동작 원리, 시간 복잡도에서 설명하라  
우선 풀스캔 같은 경우 최악의 경우 O(N)의 시간 복잡도를 가짐      

# 3. 인덱스 종류 

1. Clusterd Index : 인덱스와 데이터가 군집해있다.    
2. NonClusterd Index : 


## Clusterd Index  

![image](https://user-images.githubusercontent.com/50267433/138220557-584c2444-b831-470f-9403-cc3bcbdde3ab.png)

  
인덱스와 데이터가 군집해있다.     
데이터가 정렬된 상태이기에 범위 검색을 할 땐 아주 강력하다(정렬 -> 이진 탐색 이용 가능)         

![image](https://user-images.githubusercontent.com/50267433/138220592-f6a1bf77-8d5f-4ea6-84e5-ca616b88f6d6.png)

그러나 반대로 정렬된 상태이기에 **값을 추가하는 과정에서 재정렬**이 일어나듯이 정렬 비용이 커지면 성능이 악영향을 미친다.    

클러스터드 인덱스는 테이블당 한개만 존재하는데     
기본적으로 PK고 없으면 Unique NOTNULL 컬럼이 인덱스가 된다.    
즉, 둘다 있으면 PK가 클러스터드 인덱스가 된다.   
  
클러스터 인덱스는 테이블에 한개만 생성된다.       

정리하자면   
* 순서대로 
* 한 테이블에 하나만 
* 범위 검색에 좋다.   
* 존재하는 PK 사이에 INSERET 할 경우 대참사
* Auto_Increment 
* 카디널리티가 넓을 수록 오히려 유리하다.  


낫널에 유니크로 가능  

## NonClusterd Index   

![image](https://user-images.githubusercontent.com/50267433/138220705-b61c4405-9cf8-4469-9151-00e31a197555.png)
    
이름 그대로 데이터와 인덱스가 연결되어 있지 않다.           
인덱스가 다른 어떤 인덱스와 연결되어 있고, 그 인덱스가 데이터를 참조하고 있다.          
즉, 중간 참조 인덱스를 통해서 데이터를 찾는다.       
  
약한 참조 관계로 되어있어서(즉, 실제 데이터랑 연결된 인덱스는 따로 있어서)        
현재 인덱스들의 정렬을 할 필요가 없다.         
해시 방식을 이용해서 key를 통해 value 를 찾고 그 value의 인덱스로 데이터를 찾는 구조이다.      

정리하자면  

* 순서 상관 없음      
* 해시 방식으로 PK를 찾고 PK로 데이터를 다시 찾기 때문     
* 한 테이블에 여러개 존재할 수 있다.(각 컬럼마다 인덱스 걸 수 있음)    
* 추가 저장 공간 필요(약 10%)          
* INSERT시 추가 작업 필요(인덱스 생성 -> 어떤 행이 들어올 때 이것에 대한 인덱스 생성해야함)         
* Cardinality 카디널리티 -> 인덱스의 효율을 판단 -> 고유한 값을 나타내는 애를 인덱스로 잡아야 카디널리티 높아짐 (인덱스 판단 기준)  

# 왜?  

```
@Id 
String email 
```

PK는 클러스터드 인덱스이다.   
즉, 범위 읽기에는 빠르지만, 데이터 추가시 성능 이슈가 있을 수 있다.     
예를 들어 a-z로 이루어진 정보가 있을때 내가 m을 입력한다면? n-z까지의 데이터는 밀리고 그 사이에 m이 들어온다.      

```
@Id
Int id
```
반면에 Int를 PK로 선언할 경우,    
숫자가 차례대로 들어오기 때문에 중간에 들어와 정렬이 이루어지는 과정이 발생하지 않고   
Int id의 값으로 범위 계산도 되므로 유용함   


대신 

```
String email  // 
```

이러한 경우에는 NON-CLUSTERD INDEX가 낫다.           
저장 과정에서도 문제가 없기 때문에 좋으며     
데이터가 고유하기에 해시를 통해 나오는 값이 1개일테고 이로 인해 빠르게 찾을 수 있다.       
(증복되면, 중복된 애들끼리의 카디널리티가 넓기 때문에 최악의 경우 O(N)도 나옴)                

# 기타 

* 데이터는 내가 원하는 데이터를 어떻게 찾아 올까?    
* 왜 데이터가 많아질 수록 점점 느려질까?   
* 왜 조인만 수행하면 느려질까?    
* 왜 쿼리가 느릴까?   

# 더 보면 좋을 것   
* Explain, 실행 계획 
* B-Tree, page(Block) in innoDB 
* Cardinality  -> 예상 건수 
* CompositeKey -> 이건 처음 들어봄 
* innoDB_BUFFER_POOL_SIZE
* log_THROTTLE_QUeries_NOT_USING_INDEXES  



