# 우아한 레디스  

**다루지 않는 내용**   
* Redis Persistence(RDB, AOF). 
* Redis Pub/Sub 
* Redis Stream 
* 확률적 자료구조 
    * Hyperloglog
* Redis Module  

# 레디스 간략 소개   

* In-Memory Data Structure Store.  
* Open Source(BSD 3 License - 수정 가능)    
* Support data structures.  
    * Strings, set, sorted-set, hashes, list
    * Hyperloglog, bitmap, geospatial index 
    * Stream
* Only 1 Committer 

## 캐시 

* 나중에 사용될 요청의 결과를 미리 저장해두었다가 빠르게 서비스를 해주는 것을 의미   

**CPU CACHE**   
* Disk
* Memory 
* L3 Cache 
* L2 Cache
* L1 Cache
* Core 

**파레토 법칙**    
* 우리 사회에 일어나는 현상은 80:20 으로 이루어진다.   
* 전체 요청의 80%는 20%의 사용자가 활용 -> 캐싱 전략 사용하자   

### Cache 구조
#### Look aside Cache 

1. webServer는 데이터가 존재하는지 Cache 에 먼저 확인한다.     
2. Cache에 데이터가 있으면 Cache에서 데이터를 가져온다.      
3. Cache에 데이터가 없으면 DB에서 데이터를 가져온다.   
4. DB에서 불러온 데이터를 Cache에 다시 저장한다.   

일반적으로 제일 많이 사용하는 패턴이다.     
쓰기가 적고 읽기가 많을 때 주로 사용한다.   

#### Write Back 

1. WebServer는 모든 데이터를 Cache에만 저장한다.     
2. Cache에 특정 시간동안의 데이터가 저장된다.      
3. Cache에 있는 데이터를 DB에 저장한다.      
4. DB에 저장된 데이터를 삭제한다.    
    
인메모리가 읽기는 물론 쓰기도 빠르다.        
쓰기가 빈번한 경우, 배치 형식으로 레디스에 저장해두었다가 DB에 저장하는 방식이다.        
**단, 단점으로 메모리기에 리프팅되면 날라가게 되므로 데이터가 사라질 가능성이 있다.**      

WriteBack은 주로 로그를 DB에 저장할 때 사용한다.(한번에 밀어났다가 일정 주기별로 한번에 보낸다)     
또는 극단적으로 헤비한 Write가 있다면 사용한다.   

## Redis 사용처 

* Remote Data Server 
    * A서버, B서버, C서버에서 데이터를 공유하고 싶을 때,    
* 한대에서만 필요하다면, 전역 변수를 쓰면 되지 않을까?     
    * Redis 자체가 Atomic을 보장해준다(싱글 스레드라)  
* 주로 많이 쓰이는 곳  
    * 인증 토큰을 저장(Stirngs 또는 hash). 
    * Ranking 보드를 사용(SortedSet) 
    * 유저 API Limit
    * 잡큐(List) 


# Redis Collections 
##  왜 Collection이 중요한가
  
memCached는 Collection을 제공하지 않는다.       
레디스는 Collection을 제공해줌으로써 이로 인한 개발의 편의성과 난이도가 달라진다.          
 
**랭킹 서버**     
* 서버가 여러대인데 싱크 맞추는데 어려움이 있다.    
* 가장 간단한 방법 
    * DB에 유저의 Score 저장하고 Score로 Order by로 정렬 후 읽기 
    * 개수가 많아지면 속도에 문제가 발생할 수 있다.     
        * 결국 디스크를 사용하므로  

* In-Memory 기준으로 랭킹 서버의 구현이 필요한데   
* Redis의 sorted Set을 이용하면 랭킹을 구현할 수 있다.   
    * 덤으로 Replication 도 가능하다.   
    * 다만 가져다 쓰면 거기의 한계에 종속적이게 된다.   
        * 랭킹에 저장해야할 id가 1개당 100Byte라고 했을 대   
            * 10명 1K
            * 10000명 1M
            * 10000000명 1G
            * 10000000000명 1TB
   
**친구 리스트**   
* 친구 리스트를 Key/Value 형태로 저장한다면?    
* 현재 유저 123의 친구 key는 friends:123, 현재 친구 A가 있는 중  
    * 트랜잭션1
        * 친구 리스트 friends:123을 읽는다.  
        * friends:123의 끝에 친구 B를 추가한다.   
        * 해당 값을 frend:123에 저장한다.  
    * 트랜잭션2 
        * 친구 리스트 friends:123을 읽는다  
        * friends:123의 끝에 친구 C를 추가한다.   
        * 해당 값을 frineds:123에 저장한다.  

* 동시성 문제가 발생하면 아래와 같다.  
    * AB
    * AC
* Redis의 경우는 자료구조가 Atomic 하기 때문에 RaceCondition을 피할 수 있다.     
* 그래도 잘못짜면 발생한다.(클릭을 빠르게 2번하면 중복 데이터 발생)       
   
외부의 Collection을 잘이용하는 것으로,    
여러가지 개발 시간을 단축시키고ㅡ 문제를 줄여줄 수 있기 때문에 Collection이 중요하다.    

## Redis Collections 

* Strings
* List
* Set
* SortedSet(Score를 통해 순서를 줄 수 있다) 
* Hash

### Strings

* set key value
* get key
* set token:1234567 abcdefghijk
* get token:1234567

여기서 중요한건 명령어가 아닌 key이다.    
1234567와 같은 prefix를 주면 식별자로 여러 방면으로 사용할 수 있다.   
 
* mset key value key value 한번에 여러개 저장
* mget key key key 

### List

* Lpush key A
    * key:(A) 
* Rpush key B
    * key:(A ,B)
* Lpush key C
    * key:(C, A ,B)
* Rpush key DA
    * key:(C, A ,B, D, A)

잡큐는 리스트를 많이 쓴다.   
  
  * LPOP : 왼쪽에서 꺼내기 
  * RPOP : 오른쪽에서 꺼내기 
  * BLPOP : 데이터를 PUSH 하기 전까지 대기  

### Set 

* SADO key value : 벨류 추가 
* SMEMERS key : 모든 값 가져옴(추가하자)
* SISMEMBERS key value : value가 존재하면 1, 없으면 0
* 특정 유저를 Follow 하는 목록 저장시 사용 

### Sorted Set 

* ZADO key score value : score 기준으로 정렬(우선순위) 
* ZRANGE key startindex endindex : 해당 인덱스 범위값을 모두 가져온다.  
    * Zrange testkey 0~1
    * 모든 범위 가져옴 
* 유저 랭킹 보드로 사용할 수 있다.  
    * SoretedSets의 socre는 double 타입이기 때문에, 값이 정확하지 않을 수 있다.   
    * 데이터에서는 실수가 표현할 수 없는 정수값들이 존재한다.  
    * 자바스크립트 사용한다면 long 값은 String으로 보내는 것이 좋다.  
    * 의외로 생각보다 문제가 종종 발생 
        * 특정 유저의 글을 시간값으로 주고 오늘 부터 내일까지 가져오는데 빠질 수 있음
        * 어제꺼인데 들어올 수 있음 

**정렬이 필요한 값이 필요하다면?**     
* select * from rank order by score limit 50, 20; 
    * zrange rank 50 70
* select * from rank order by score desc limit 50 20;
    * Zrevrange rank 50 70 // 거꾸로 가져옴 

**Score 기준으로 뽑고 싶다면?**    
* select * from rank where score >= 70 and score < 100;
    * zrangebyscore rank 70 100 
* select * from rank where score > 70;
    * zrangebyscore rank (70 +inf
  
### Hash
> key 밑에 Sub key가 존재한다.    

**기본 사용법**    
* hashset key subkey1 value subkey2 value
* hagetall key 
    * 해당 key의 모든 서브키와 value를 가져옴   
* hget key 서브키 
* hmget ket 서브키1 서브키2 서브키3   

**간단한 SQL을 대체한다면**    
* insert into users(name, email) values('charsyam', 'kwj1270@naver.com');
* hmset charsyam name cahrsyam email kwj1270@naver.com

### Collection 주의 사항   
* 하나의 컬렉션에 너무 많은 아이템을 담으면 좋지 않음     
    * 10000개 이하 몇 천개 수준으로 유지하는게 좋음     
* Expire는 Collection의 item 개별로 걸리지 않고 전체 Collection에 대해서만 걸림      
    * 즉, Collection에 expire가 걸려있다면 아이템 모두 삭제        
    
# Redis 운영 

* 메모리 관리를 잘하자    
* O(N) 관련 명령어는 주의하자.  
* Replication 
* 권장 설정 Tip 

## 메모리 관리를 잘하자   
     
* Redis는 In-Memory Data Store      
* Physical Memory 이상을 사용하면 문제가 발생한다.          
    * Swap이 있다면 Swap 사용으로 해당 메모리 Page 접근마다 늦어진다.        
    * Swap이 없다면?    
* Maxmemory를 설정하더라도 이보다 더 사용할 가능성이 크다.       
* RSS값을 모니터링 해야함 (레디스가 실제 메모리를 사용하고 있는 메모리)     
  
즉, 많은 업체가 현재 메모리를 사용해서 SWAP을 쓰고 있다느걸 모를때가 많다.     
    
* 큰 메모리를 사용하는 instance 하나보다는 적은 메모리를 사용하는 instance 여러개가 안전하다.    
* CPU 4 Core, 32GB Memory      

파편화 
  
* Redis는 메모리 파편화가 발생할 수 있다.    
    * 4.x대부터 메모리 파편화를 줄이도록 jemlloc에 힌트를 주는 기능이 들어갔으나.      
    * jemalloc 버전에 따라서 다르게 동작할 수 있다.      
* 3.x대 버전   
    * 실제 user memory는 2GB로 보고가 되지만 11GB의 RSS를 사용하는 경우가 자주 발생     
* 다양한 사이즈를 가지는 데이터보다는 유사한 크기의 데이터를 분리하는 경우가 유리(클러스터..?)   
 
#### 메모리가 부족할 때는? 
 
* Cache is Cash!!!   
    * **좀 더 메모리 많은 장비로 Migration**      
    * 메모리가 빡빡하면 Migration 중에 문제가 발생할 수도...    
* 있는 데이터 줄이기    
    * **데이터를 일정 수준에서만 사용하도록 특정 데이터를 줄인다.**          
    * 다만 이미 Swap 을 사용중이라면, 프로세스를 재시작 해야함     
    * 클러스터 운영도 고민 

##### 메모리가 줄이기 위한 설정 
* 기본적으로 Collection 들은 다음과 같은 자료구조를 사용한다.   
    * Hash -> HashTable 하나 더 사옴   
    * SortedSet -> Skiplist와 HashTable을 이용   
    * Set -> HashTable  
    * 해당 자료구조들은 메모리를 많이 사용한다.    
* Ziplist를 이용하자.  
  
##### Ziplist 구조     
* In-memory 특성상, 적은 개수라면 선형 탐색을 하더라도 빠르다.        
* List, hash, SortedSet. 등을 ZpiList로 대체해서 처리하는 설정이 존재      
    * hash-max-ziplist-entries, hash-max-ziplist-value    
    * list-max-zpilist-size, list-max-ziplist-value.   
    * zset-max-ziplist-entries, zset-max-ziplist-value. 

## O(N)관련 명령어는 주의하자.   
* Redissms Single Threaded. 
    * 그러면 Redis가 동시에 여러 개의 명령을 처리할 수 있을까?    
    * 참고로 단순한 get/set의 경우, 초당 10만 TPS 이상 가능(CPU속도에 영향을 받습니다)   
    * 그냥 일반적으로 하나의 스레드로 사용하는 것이 낫다.  




 * 
 * 디버그는 된다닛! 
 *     




 
 









# Redis 데이터 분산 
# Redis Failover 
